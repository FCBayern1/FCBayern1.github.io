<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="joshua" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>webscience |  Mingwei’s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-webscience"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  webscience
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/28/webscience/" class="article-date">
  <time datetime="2023-04-28T12:34:43.000Z" itemprop="datePublished">2023-04-28</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">12.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">74 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Revision"><a href="#Revision" class="headerlink" title="Revision"></a>Revision</h1><h2 id="Topic-1-Social-Media-Twitter-Crawl"><a href="#Topic-1-Social-Media-Twitter-Crawl" class="headerlink" title="Topic 1- Social Media (Twitter) Crawl"></a>Topic 1- Social Media (Twitter) Crawl</h2><h3 id="L1-TwitterData"><a href="#L1-TwitterData" class="headerlink" title="L1 TwitterData"></a>L1 TwitterData</h3><h4 id="Exploitation-of-the-twitter-data"><a href="#Exploitation-of-the-twitter-data" class="headerlink" title="Exploitation of the twitter data:"></a>Exploitation of the twitter data:</h4><p>With the amount of content posted to social media websites every day, such as Twitter, there is huge potential for its exploitation in many scenarios, such as:</p>
<p><strong>Sports and Finance:</strong> Stock market prediction &amp; Sports betting</p>
<p>predict stock market changes based on the sentiment of tweets</p>
<ul>
<li>Sentiment expressed in tweets had been used to predict stock market reactions</li>
<li>Opinions of investors’ posts on social media</li>
<li>combine with the stock prize movements</li>
</ul>
<p>Sports betting</p>
<h4 id="Web-Science-Concepts"><a href="#Web-Science-Concepts" class="headerlink" title="Web Science Concepts"></a>Web Science Concepts</h4><ul>
<li><p>﻿﻿Explore the science underlying the web</p>
<ul>
<li>﻿﻿From a socio-technical perspective</li>
<li>﻿﻿Mathematical properties, engineering principles, social impacts</li>
</ul>
</li>
<li><p>﻿﻿Understanding users and developing Web applications for them!</p>
<ul>
<li>﻿﻿Sociology &amp; Web Engineering</li>
</ul>
</li>
<li><p>﻿﻿Consulting corporations about social media activities</p>
<ul>
<li>﻿﻿Economics &amp; Web analvtics</li>
<li>﻿﻿For example, role of micro influencers on local economy</li>
<li>﻿﻿How much hate a brand page generates due to some comments, ….</li>
</ul>
</li>
<li><p>﻿﻿Data analvtics</p>
<ul>
<li>﻿﻿Growth of information; structured and unstructured</li>
<li>﻿﻿Intersection of networks &amp; data</li>
</ul>
</li>
<li><p>Broble mew technologies to scientists and engineers working together on large scale</p>
</li>
</ul>
<h3 id="L2-DataClustering"><a href="#L2-DataClustering" class="headerlink" title="L2 DataClustering"></a>L2 DataClustering</h3><h4 id="Content-processing"><a href="#Content-processing" class="headerlink" title="Content processing"></a>Content processing</h4><h4 id="1-Removing-stuff"><a href="#1-Removing-stuff" class="headerlink" title="1. Removing stuff"></a>1. Removing stuff</h4><ul>
<li>Non-ascii removal</li>
</ul>
<p>remove the emoji…</p>
<p>![image-20230429103013009](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230429103013009.png)</p>
<h4 id="2-Grouping-tweets"><a href="#2-Grouping-tweets" class="headerlink" title="2. Grouping tweets"></a>2. Grouping tweets</h4><ul>
<li>﻿﻿Based on content analysis like<ul>
<li>﻿﻿Clustering, locality sensitive hashing</li>
<li>﻿﻿Or through content indexes</li>
</ul>
</li>
<li>﻿﻿Once we know the groups<ul>
<li>﻿﻿We could analyse the words, user mentions, hashtags in these groups</li>
<li>﻿﻿We can add these terms to a list with a priority</li>
<li>﻿﻿This is possibly for identifying more tweets of this type<ul>
<li>﻿﻿Aim is data gathering</li>
</ul>
</li>
</ul>
</li>
<li>﻿﻿We can also look at proficient tweeters<ul>
<li>﻿﻿What are their total tweets</li>
</ul>
</li>
</ul>
<h4 id="3-Tokenization"><a href="#3-Tokenization" class="headerlink" title="3. Tokenization"></a>3. Tokenization</h4><p>Separate each token</p>
<p>Remove stopwords</p>
<h4 id="4-Vector-Representation"><a href="#4-Vector-Representation" class="headerlink" title="4. Vector Representation"></a>4. Vector Representation</h4><p>Documents are represented by a term vector</p>
<p><em>Di</em> &#x3D; (ti1,ti2 ,….,tin )</p>
<p>Queries are represented by a similar vector</p>
<p>• In binary scheme, tik is set to 1 when term k is present in Document i otherwise they are set to zero</p>
<ul>
<li>The most relevant documents for a query are expected to be those represented by the vectors closest to the query, that is documents that use similar words to the query.</li>
<li>﻿﻿Closeness is often calculated by just looking at angles between document vector and query vector</li>
<li>﻿﻿We need a similarity measure!<ul>
<li>Cosine similarity measure</li>
<li>Jaccard coefficient</li>
<li>Dice coefficient</li>
</ul>
</li>
</ul>
<h4 id="Finding-similar-tweets-Single-pass-clustering"><a href="#Finding-similar-tweets-Single-pass-clustering" class="headerlink" title="Finding similar tweets Single-pass clustering"></a>Finding similar tweets Single-pass clustering</h4><p><strong>Single-pass clustering</strong></p>
<ul>
<li><p>requires a single, sequential pass over the set of documents it attempts to cluster.</p>
</li>
<li><h4 id="The-algorithm-classifies-the-next-document-in-the-sequence-according-to-a-condition-on-the-similarity-function-employed"><a href="#The-algorithm-classifies-the-next-document-in-the-sequence-according-to-a-condition-on-the-similarity-function-employed" class="headerlink" title="The algorithm classifies the next document in the sequence according to a condition on the similarity function employed."></a>The algorithm classifies the next document in the sequence according to a condition on the similarity function employed.</h4></li>
<li><p>At every stage, <strong>the algorithm decides on whether a newly seen document should become a member of an already defined cluster or the centre of a new one.</strong></p>
<ul>
<li>In its most simple form, the similarity function gets defined on the basis of just some similarity (or alternatively, dissimilarity) measure between document-feature vectors.</li>
</ul>
</li>
</ul>
<p>![image-20230429121645868](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230429121645868.png)</p>
<p>Comments on Single Pass Method</p>
<ul>
<li>﻿﻿The single pass method is particularly simple<ul>
<li>﻿﻿since it requires that the data set be processed only once.</li>
</ul>
</li>
<li>﻿﻿Obviously, the results for this method are highly dependent on the similarity threshold that is used.</li>
<li>﻿﻿It tends to produce large clusters early in the clustering pass,<ul>
<li>﻿﻿and because the clusters formed are not independent of the order in which the data set is processed.</li>
<li>﻿﻿You should use your judgment in setting this threshold so that you are left with a reasonable number of clusters.</li>
</ul>
</li>
<li>﻿﻿It is sometimes used to form the groups that are used to initiate reallocation clustering.<ul>
<li>﻿﻿If we get a large noisy clusters of tweets, we could re-cluster them!!!</li>
</ul>
</li>
</ul>
<h3 id="L3-Credibility-amp-Newsworthiness"><a href="#L3-Credibility-amp-Newsworthiness" class="headerlink" title="L3 Credibility &amp; Newsworthiness"></a>L3 Credibility &amp; Newsworthiness</h3><h4 id="Newsworthy"><a href="#Newsworthy" class="headerlink" title="Newsworthy"></a><strong>Newsworthy</strong></h4><p>Key characteristics of newsworthy score</p>
<ul>
<li>﻿﻿Real-time<ul>
<li>﻿﻿Tweets should be scored as soon as it arrives!</li>
</ul>
</li>
<li>﻿﻿Generalizability<ul>
<li>﻿﻿Should be able to handle any types of events - not those just seen before</li>
</ul>
</li>
<li>﻿﻿Adaptive<ul>
<li>﻿﻿New information to be incorporated, as and when they arrive</li>
<li>﻿﻿Incorporate new information to the scoring model</li>
</ul>
</li>
</ul>
<p>These characteristics should be realized with the help of <strong>classification approach</strong> and <strong>distant supervision</strong>.</p>
<h4 id="HeurisIc-Labelling"><a href="#HeurisIc-Labelling" class="headerlink" title="HeurisIc Labelling"></a><strong>HeurisIc Labelling</strong></h4><ul>
<li>﻿﻿Semi-automatic labelling approach<ul>
<li>﻿﻿Using a set of heuristics to label<ul>
<li>﻿﻿High quality (newsworthy) and low quality (noisy) content</li>
</ul>
</li>
</ul>
</li>
<li>﻿﻿This will not label majority of the content</li>
<li>﻿﻿Advantages<ul>
<li>﻿﻿Minimal effort in creating a data set</li>
<li>﻿﻿Real-life data set - incremental and generalizable</li>
<li>﻿﻿Easily built as part of an algorithm for example event detection</li>
</ul>
</li>
</ul>
<p><strong>Overall approach</strong></p>
<ul>
<li><p>Collect a set of high-quality sets and low-quality sets of data</p>
</li>
<li><p>Use this dataset to potentially score a newsworthy tweet</p>
</li>
</ul>
<h4 id="Quality-Score"><a href="#Quality-Score" class="headerlink" title="Quality Score"></a>Quality Score</h4><p>Quality Score &#x3D; (profileWeight + verifiedWeight + followers Weight + accountAgeWeight + descriptionWeight)&#x2F;5</p>
<p>Range is [0 to 1]</p>
<p>if q score is higher than 0.65 -&gt; high quality </p>
<p>if q score is lower than 0.45 -&gt; low quality</p>
<h4 id="Scoring-model"><a href="#Scoring-model" class="headerlink" title="Scoring model"></a>Scoring model</h4><p>Likelihood ratio for each term</p>
<ul>
<li>﻿﻿R(t) &#x3D; relative importance of term in the particular quality model when compared to random background model</li>
<li>﻿﻿&gt;1<ul>
<li>﻿Term is more common in the model than random</li>
</ul>
</li>
<li>﻿﻿&lt;1<ul>
<li>﻿﻿Term is less common in the model than random</li>
</ul>
</li>
</ul>
<p>![image-20230429134512747](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230429134512747.png)</p>
<p><strong>cntd</strong></p>
<p>if RHQ(t)&lt;2 or RLQ(t)&lt;2 then the Score will be set 0 as to remove the terms which have no clear association with either high quality content or low-quality content.</p>
<p>![image-20230429134931099](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230429134931099.png)</p>
<h3 id="L4-Geo-localisation"><a href="#L4-Geo-localisation" class="headerlink" title="L4-Geo-localisation"></a>L4-Geo-localisation</h3><h4 id="Fine-grained-localization"><a href="#Fine-grained-localization" class="headerlink" title="Fine-grained localization"></a>Fine-grained localization</h4><p>Fine-grained localization refers to the task of accurately localizing objects or entities within an image or a video with high precision, usually at a sub-pixel or sub-object level. This involves identifying the precise location of the object, as well as any associated attributes such as shape, texture, and color.</p>
<p>The goal of fine-grained localization is to provide more detailed and accurate information about the location and properties of objects in an image, which can be useful for a range of applications such as object tracking, object recognition, and scene understanding.</p>
<p>Fine-grained localization can be challenging due to the variability in object appearance, pose, and scale. To overcome these challenges, various techniques such as deep learning and computer vision algorithms have been developed.</p>
<p>Examples of fine-grained localization tasks include localizing individual bird species in a bird-watching image, identifying specific car models in a crowded parking lot, or detecting the presence of a particular species of fish in an underwater video.</p>
<p><strong>Problem statement</strong></p>
<ul>
<li>﻿﻿Geo-localization<ul>
<li>﻿﻿Provide location estimates for individual tweets</li>
</ul>
</li>
<li>﻿﻿coarse-grained Geo-localization<ul>
<li>﻿﻿Provide location estimates for individual tweets at regional or country level</li>
</ul>
</li>
<li>﻿﻿fine-grained Geo-localization<ul>
<li>﻿﻿Provide location estimates for individual tweets at city or neighbourhood level</li>
</ul>
</li>
<li>﻿﻿Approach<ul>
<li>﻿﻿Train a model on a geo-tagged data set<ul>
<li>﻿﻿Validate and test on geo-tagged data</li>
<li>﻿﻿Test on non-geo tagged data as well</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Topic3-Topic-modelling"><a href="#Topic3-Topic-modelling" class="headerlink" title="Topic3 Topic modelling"></a>Topic3 Topic modelling</h2><h3 id="Topic-modelling"><a href="#Topic-modelling" class="headerlink" title="Topic modelling"></a>Topic modelling</h3><h4 id="Discuss-why-searching-is-limited-when-exploring-a-collection"><a href="#Discuss-why-searching-is-limited-when-exploring-a-collection" class="headerlink" title="Discuss why searching is limited when exploring a collection"></a><strong>Discuss why searching is limited when exploring a collection</strong></h4><p>When exploring a collection, searching can be limited by various factors such as the completeness and accuracy of the metadata, the complexity of the query, and the quality of the search algorithm.</p>
<p>Firstly, the completeness and accuracy of the metadata associated with each item in the collection can limit the effectiveness of searching. If the metadata is incomplete or inconsistent, important information about an item may not be captured, making it difficult or impossible to find through search queries.</p>
<p>Secondly, the complexity of the search query can also limit the effectiveness of searching. For example, if a user is looking for items that have multiple attributes or characteristics, such as a specific color and shape, the search query may become too complex and difficult to execute accurately.</p>
<p>Finally, the quality of the search algorithm used to explore the collection can also limit the effectiveness of searching. If the algorithm is not designed to handle the specific characteristics of the collection or the query, it may return irrelevant or incomplete results.</p>
<p>To overcome these limitations, various techniques can be employed such as using natural language processing to simplify complex search queries, improving the quality and completeness of metadata through manual curation or machine learning techniques, and using advanced search algorithms that take into account the specific characteristics of the collection and query.</p>
<p>Topic modelling is the process of using a topic model to discover the <strong>hidden topics</strong> that are represented by a large collection of documents</p>
<ul>
<li><p>Observed</p>
<ul>
<li><p>﻿﻿collection</p>
</li>
<li><p>﻿﻿Document &amp; words</p>
</li>
</ul>
</li>
<li><p>﻿﻿Aim</p>
<ul>
<li>﻿﻿Use the observed information to infer<ul>
<li>﻿﻿Hidden structure</li>
</ul>
</li>
</ul>
</li>
<li><p>﻿﻿Topic structure - hidden</p>
<ul>
<li>﻿﻿per document topic distributions</li>
<li>﻿﻿Per document per-word topic assignments<ul>
<li>﻿﻿Annotation…</li>
<li>﻿﻿Can be used for retrieval, classification, browsing?</li>
</ul>
</li>
</ul>
</li>
<li><p>﻿﻿Utility</p>
<ul>
<li>﻿﻿Inferred hidden structure resembles the thematic structure of the collection</li>
</ul>
</li>
</ul>
<p><strong>latent</strong></p>
<p>(of a quality or state) existing but not yet developed or manifest hidden or concealed.;</p>
<p>Topic modelling </p>
<ul>
<li>A machine learning approach for Mining latent topics</li>
</ul>
<p>Identify hidden, gigantic structures</p>
<p>Probabilistic topic models</p>
<ul>
<li>a suite of algorithms that aim to discover and annotate large archives of documents of thematic information</li>
</ul>
<h4 id="Our-goal-in-topic-modelling"><a href="#Our-goal-in-topic-modelling" class="headerlink" title="Our goal in topic modelling"></a>Our goal in topic modelling</h4><ul>
<li>﻿﻿The goal of topic modeling is to automatically discover the topics in a collection of documents</li>
<li>﻿﻿Documents are observed<ul>
<li>﻿﻿Topics, per-document and per-word topic assignments - hidden</li>
<li>﻿﻿Hence latent!</li>
</ul>
</li>
<li>﻿﻿The central computation problem for topic modelling is to use the observed documents to infer hidden topic structure</li>
<li>﻿﻿Think it as reversing the generative process<ul>
<li>﻿﻿What is the hidden structure that likely generated the observed collection?</li>
</ul>
</li>
</ul>
<h4 id="LDA-Latent-Dirichlet-Allocation"><a href="#LDA-Latent-Dirichlet-Allocation" class="headerlink" title="LDA (Latent Dirichlet Allocation)"></a>LDA (Latent Dirichlet Allocation)</h4><ul>
<li><p>﻿﻿Is a statistical model of document collections that tries to capture the intuition<br> Each document can be described by a distribution of topics and each topic can be described by a distribution of words</p>
</li>
<li><p>﻿﻿Topic</p>
<ul>
<li><p>﻿﻿Defined as a distribution over the words&#x2F; fixed vocabulary</p>
<ul>
<li><p>E.g., genetic topic has words about genetics (sequenced, genes) with high probability</p>
</li>
<li><p>﻿﻿Evolutionary biology has words like life, organism with high probability</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Topic-Modelling-Approaches"><a href="#Topic-Modelling-Approaches" class="headerlink" title="Topic Modelling Approaches"></a>Topic Modelling Approaches</h4><ul>
<li>Number of possible topic structures is exponentially large</li>
<li>Approximate the posterior distribution</li>
<li>Topic modelling algorithms form an approximation of equation, <ul>
<li>by adapting an alternative distribution over latent topic structure to be close to the true posterior</li>
</ul>
</li>
</ul>
<p>Two approaches:</p>
<p><strong>1. Sampling based!</strong></p>
<p>Attempt to collect samples from the posterior to approximate it with an empirical distribution <strong>– Gibbs sampling!</strong></p>
<p><strong>2. Variational methods!</strong></p>
<p>Deterministic alternative to sampling based methods</p>
<p>Posit a parametrised family of distributions over the hidden structure and then find the member of that family that is closest to the posterior</p>
<p><strong>Summary</strong></p>
<p>The user specifies that there are K distinct topics</p>
<p>​	Each of the K topics is drawn from a aDirchlet distribution</p>
<p>​		Uniform base distribution (u) and concentration parameter B</p>
<p>​		theta_k ~ Dir(Bu)</p>
<p>Distributions over topics of each document 	theta_d ~ Dir (au)</p>
<ul>
<li>﻿﻿Topic assignment Z_d,n ~ Discrete(theta_d)</li>
<li>﻿Wd,n~theta_Z(d,n)</li>
</ul>
<p><strong>Sampling based!</strong></p>
<p>Attempt to collect samples from the posterior to approximate it with an empirical distribution - <strong>Gibbs sampling!</strong></p>
<p><strong>Variational methods!</strong></p>
<p>Deterministic alternative to sampling based methods</p>
<p>Posit a parametrised family of distributions over the hidden structure and then find the member of that family that is closest to the posterior</p>
<p><strong>Gibbs Sampling</strong></p>
<p>It generates samples from complex, high-dimensional probability distributions.</p>
<p>The algorithm for Gibbs sampling is as follows:</p>
<ol>
<li>Initialize each variable with an initial value.</li>
<li>Choose a variable to update, say the i-th variable.</li>
<li>Sample a new value for the i-th variable from its conditional distribution, given the current values of the other variables.</li>
<li>Repeat steps 2 and 3 for a specified number of iterations or until convergence is achieved.</li>
</ol>
<h4 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a><strong>LDA</strong></h4><ul>
<li><p>﻿﻿LDA is a probabilistic generative model</p>
<ul>
<li>﻿﻿Each document is a distribution of topics</li>
<li>﻿﻿Each topic is a distribution of words</li>
</ul>
</li>
<li><p>﻿﻿Sample a topic from a document-level topic distribution</p>
<ul>
<li>﻿﻿That obeys Dirichlet distribution</li>
</ul>
</li>
<li><p>﻿﻿Then sample a words according to the topic distribution of this topic</p>
<ul>
<li>﻿﻿Dirichlet distribution</li>
</ul>
</li>
<li><p>﻿﻿Generate a document</p>
</li>
<li><p>﻿﻿Hence, LDA implicitly model document level word co-occurrence pattern</p>
</li>
<li><p>﻿﻿Sparsity problem exacerbates performance issues</p>
<ul>
<li>﻿﻿The limited contexts make it more difficult for topic models to identify the senses of ambiguous words in short documents.</li>
</ul>
</li>
<li><p>﻿﻿Short documents like Tweet</p>
<ul>
<li>﻿﻿Sparse words …</li>
<li>﻿﻿Time-sensitive</li>
<li>﻿﻿Lack of clear context because not much information; no formal structure<ul>
<li>﻿﻿How words are related often measured through co-occurrence patterns</li>
<li>﻿﻿In short texts document-level co-occurrence patterns are difficult to capture</li>
</ul>
</li>
</ul>
</li>
<li><p>﻿﻿Massive volume of tweet;</p>
<ul>
<li>﻿﻿Memory requirements</li>
</ul>
</li>
<li><p>﻿﻿Real-time nature</p>
</li>
</ul>
<p>Problem with LDA to train twitter</p>
<p><strong>Why not LDA?</strong></p>
<ul>
<li>LDA needs to be trained on the entire data sets<ul>
<li>Memory requirements for the model</li>
</ul>
</li>
<li>LDA is trained and tested on a data set<ul>
<li>Time-sensitive nature of Twitter</li>
</ul>
</li>
</ul>
<p>How to address this issue …?</p>
<ul>
<li>﻿﻿Enrich the word co -occurrence information<ul>
<li>﻿﻿To enrich the limited word co -occurrence information contained in a single short text,</li>
</ul>
</li>
<li>﻿﻿Make larger texts by grouping short texts (tweets)<ul>
<li>﻿﻿Grouping tweets by the authors</li>
<li>﻿﻿However, this aggregation method highly depends on the meta - information of each text,<ul>
<li>﻿﻿which may not always be available for many kinds of short texts.</li>
</ul>
</li>
<li>﻿﻿Another strategy models the similarity between texts to aggregate similar texts into a long pseudo -document</li>
</ul>
</li>
<li>﻿﻿Explicit text similarity</li>
</ul>
<h2 id="Topic4-Network-Analysis"><a href="#Topic4-Network-Analysis" class="headerlink" title="Topic4 Network Analysis"></a>Topic4 Network Analysis</h2><h3 id="L6-Graph-based-Network-Analysis"><a href="#L6-Graph-based-Network-Analysis" class="headerlink" title="L6 Graph-based Network Analysis"></a>L6 Graph-based Network Analysis</h3><h4 id="Graph-Modelling"><a href="#Graph-Modelling" class="headerlink" title="Graph Modelling"></a>Graph Modelling</h4><ul>
<li>﻿﻿Capturing structural properties of social networks</li>
<li>﻿﻿Relationships formed between individuals<ul>
<li>﻿﻿To identify clusters</li>
<li>﻿﻿Cliques and connected components of users</li>
<li>﻿﻿Centrality measures</li>
</ul>
</li>
<li>﻿﻿Hashtags<ul>
<li>﻿﻿Which hashtags are strongly connected</li>
</ul>
</li>
</ul>
<p><strong>Centrality Measures:</strong> Find the influential users, find the centre of a graph.</p>
<p><strong>Why graph?</strong></p>
<ul>
<li><p>﻿﻿By analyzing network data, we can ask many questions</p>
<ul>
<li>﻿﻿Who is most important in a network?</li>
<li>﻿﻿Which way information flows?</li>
</ul>
</li>
<li><p>﻿﻿We can use graph analysis to answer questions like these</p>
</li>
<li><p>﻿﻿Note</p>
<ul>
<li>﻿﻿Sample questions!</li>
<li>﻿﻿What are people talking about?<br> How are they responding to a product?</li>
<li>﻿﻿The breadth of such analyses is huge and not covered fully</li>
</ul>
</li>
</ul>
<h4 id="Graph-Theory"><a href="#Graph-Theory" class="headerlink" title="Graph Theory"></a><strong>Graph Theory</strong></h4><p><strong>Graph</strong></p>
<ul>
<li><p>﻿﻿Graphs are way to formally represent a network or a set of interconnected objects</p>
</li>
<li><p>﻿﻿Nodes and edges</p>
</li>
<li><p>﻿﻿Unlike trees no concept of root node, In the graph, there is no unique node which is known as root.</p>
</li>
<li><p>﻿﻿One node might be connected to five others!</p>
</li>
<li><p>﻿﻿No concept one-directional flow!</p>
</li>
</ul>
<p>﻿﻿<strong>Edges</strong></p>
<ul>
<li>﻿﻿With direction or flow!</li>
<li>﻿﻿Without direction!</li>
</ul>
<p><strong>Direction</strong></p>
<ul>
<li>﻿﻿Origin to destination</li>
</ul>
<p><strong>Trees vs graphs</strong></p>
<p>A tree is a set of nodes and edges. In a tree, there is a unique node which is known as root.</p>
<p>Terminology - <strong>Undirected</strong> graphs</p>
<ul>
<li>﻿﻿u and v are adjacent if {u, v} is an edge,<ul>
<li>﻿﻿e is called incident with u and v</li>
<li>﻿﻿u and v are called endpoints of {u, v}</li>
</ul>
</li>
<li>﻿﻿Degree of Vertex (deg (V)):<ul>
<li>﻿﻿the number of edges incident on a vertex.</li>
<li>﻿﻿<strong>A loop contributes twice to the degree</strong></li>
</ul>
</li>
</ul>
<p>Terminology - <strong>Directed</strong> graphs</p>
<ul>
<li>﻿﻿For the edge (u, v), u is adjacent to v OR v is adjacent from u,</li>
<li>﻿﻿u - Initial vertex origin)</li>
<li>﻿﻿v - Terminal vertex destination)</li>
<li>﻿﻿In-degree (deg (u)): number of edges for which u is terminal vertex</li>
<li>﻿﻿Out-degree (deg+ (u)): number of edges for which u is initial vertex</li>
</ul>
<p><strong>Incidence Matrix:</strong></p>
<p>What are the maximum potential edges?</p>
<p>Undirected graph: (n*(n-1))&#x2F;2</p>
<p>Directed graph (n*(n-1))</p>
<p>Edge density &#x3D; no of edges&#x2F; max no of edges possible</p>
<p><strong>Adjacency Matrix</strong></p>
<ul>
<li><p>﻿﻿There is an N x N matrix, where |V| &#x3D; N,</p>
</li>
<li><p>﻿﻿the Adjacenct Matrix (N×N)</p>
</li>
<li><p>﻿﻿This makes it easier to find subgraphs</p>
</li>
<li><p>﻿﻿When there are relatively few edges in the graph the adjacency matrix is a sparse matrix</p>
</li>
</ul>
<h4 id="Graph-analysis-in-twitter"><a href="#Graph-analysis-in-twitter" class="headerlink" title="Graph analysis in twitter"></a>Graph analysis in twitter</h4><p>Twitter is directed graph while facebook is undirected</p>
<p><strong>Why graph analysis?</strong></p>
<ul>
<li>﻿﻿By analyzing tweet data, we can ask many questions</li>
<li>﻿﻿Who is most important in a network?</li>
<li>﻿﻿How did the information flow?</li>
<li>﻿﻿How could we reach 50% of the graph?</li>
<li>﻿﻿Who is more influential?</li>
<li>﻿﻿What are people talking about?</li>
<li>﻿﻿How are they responding to a product?</li>
</ul>
<p><strong>Centrality</strong></p>
<p>find who is important</p>
<ul>
<li>Measures of importance in social networks are called centrality measures</li>
</ul>
<p><strong>Degree centrality</strong></p>
<ul>
<li><p>Who gets the most re-tweets?</p>
<ul>
<li>Basically says who is most important in the network</li>
</ul>
</li>
<li><p>In-degree: number of retweets of a user</p>
</li>
<li><p>Out-degree: number of retweets this particular user made</p>
</li>
<li><p>﻿﻿The degree centrality is a fundamental metric in network analysis.</p>
</li>
<li><p>﻿﻿It is used to directly quantify the number of nodes in the network that a given node is adjacent to.</p>
</li>
<li><p>﻿﻿for directed networks</p>
<ul>
<li>﻿﻿There are variations of this metric that are used, where connections between nodes have a directionality.</li>
</ul>
</li>
<li><p>﻿﻿In directed networks, it makes sense to talk about the following:</p>
</li>
<li><p>﻿﻿In-degree - For a given node, how many edges are incoming to the node.<br> the node.</p>
</li>
<li><p>﻿Out-degree - For a given node, how many edges are outgoing from</p>
</li>
<li><p>﻿﻿CD(v) &#x3D; deg(v)</p>
</li>
</ul>
<p><strong>Centrality measures!</strong></p>
<p>Designed to characterise</p>
<ul>
<li>﻿﻿Functional role - what part does this node play in system dynamics?</li>
<li>﻿﻿Structural importance - how important is this node to the structural characteristics of the system?</li>
</ul>
<p>In each of the following networks, X has higher centrality than Y according to a particular measure</p>
<p>![image-20230430204648900](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230430204648900.png)</p>
<ul>
<li>﻿﻿“Who is the most important or central person in this network?”<ul>
<li>﻿﻿There are many answers to this question, depending on what we mean by importance.</li>
</ul>
</li>
<li>﻿﻿The power a person holds in the organization is inversely proportional to the number of keys on his keyring.<ul>
<li>﻿﻿A janitor has keys to every office, and no power.</li>
<li>﻿﻿The CEO does not need a key: people always open the door for him.</li>
</ul>
</li>
<li>﻿﻿Degree centrality of a vertex</li>
</ul>
<p>![image-20230430205230578](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230430205230578.png)</p>
<p>![image-20230430210025438](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230430210025438.png)</p>
<p>Eigenvector centrality</p>
<ul>
<li><p>﻿﻿Who is the most influential</p>
</li>
<li><p>﻿﻿In contrast to degree centrality</p>
<ul>
<li>﻿﻿How important are these retweeters?</li>
</ul>
</li>
<li><p>﻿﻿is a measure of the influence of a node</p>
<ul>
<li>﻿﻿It assigns relative scores to all nodes in the network based on the concept that</li>
<li>﻿﻿connections to high-scoring nodes contribute more to the score of the node in<br> question<ul>
<li>﻿﻿than equal connections to low-scoring nodes.</li>
</ul>
</li>
</ul>
</li>
<li><p>﻿﻿Google’s page rank is variant of the eigenvector centrality.</p>
</li>
<li><p>﻿﻿Using Adjacency network</p>
<ul>
<li>﻿﻿Ax &#x3D; lambda x</li>
<li>﻿﻿there is a unique largest eigenvalue, which is real and positive,</li>
<li>﻿﻿This greatest eigenvalue results in the desired centrality measure.</li>
</ul>
</li>
</ul>
<p>Betweenness Centrality&#x2F;Closeness Centrality</p>
<p><strong>Betweenness centrality</strong> measures the number shortest paths in which the user is in the sequence of nodes in the path.</p>
<ul>
<li>It was introduced as a measure for quantifying the control of a human on the communication between other humans in social network.</li>
<li>In this conception, vertices that have a high probability to occur on a randomly chosen shortest path between two randomly chosen vertices have a high betweenness.</li>
</ul>
<p>![image-20230430213515337](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230430213515337.png)</p>
<p>Closeness Centrality: Definition</p>
<ul>
<li>﻿﻿Closeness is based on the length of the average shortest path between a vertex and all vertices in the graph</li>
<li>﻿﻿Closeness Centrality</li>
</ul>
<h3 id="L7-Retweet-Graph-Trend-amp-Influencers"><a href="#L7-Retweet-Graph-Trend-amp-Influencers" class="headerlink" title="L7_Retweet Graph Trend &amp; Influencers"></a>L7_Retweet Graph Trend &amp; Influencers</h3><p>Information diffusion ….</p>
<p>tracing, understanding and predicting how </p>
<p>a piece of information is spreading. </p>
<h4 id="Information-diffusion"><a href="#Information-diffusion" class="headerlink" title="Information diffusion"></a>Information diffusion</h4><ul>
<li><p>in online communities, tracking the information diffusion is useful for many applications, for example,</p>
<ul>
<li>﻿﻿such as early warning systems,</li>
<li>﻿﻿social bot and community detection,</li>
<li>﻿﻿user location prediction,</li>
<li>﻿﻿financial recommendations,</li>
<li>﻿﻿marketing campaign effectiveness,</li>
<li>﻿﻿political mobilization and protests</li>
</ul>
</li>
<li><p>﻿﻿Twitter offers four possible actions to express interest in specific content:</p>
<ul>
<li>﻿﻿<strong>favorite</strong>, <strong>reply</strong>, <strong>quote</strong> and <strong>retweet</strong>.</li>
<li>﻿﻿Replying or liking a tweet does not involve the spread of the content,</li>
<li>﻿﻿whereas quotes and retweets are actions used to<ul>
<li>﻿﻿share information with a wider audience.</li>
</ul>
</li>
</ul>
</li>
<li><p>﻿﻿A retweet is often considered an endorsement, i.e., the user supports the original tweet’s content,</p>
</li>
<li><p>﻿﻿whereas <strong>quoting</strong> may be done in order to express a different idea</p>
</li>
</ul>
<h4 id="Hashtags-amp-mentions"><a href="#Hashtags-amp-mentions" class="headerlink" title="Hashtags&amp;mentions"></a>Hashtags&amp;mentions</h4><ul>
<li>﻿﻿Hashtag - adding a “#” to the beginning of an unbroken word or phrase creates a hashtag.<ul>
<li>When you use a hashtag in a Tweet, it becomes linked to all of the other<br>Tweets that include it.</li>
<li>﻿﻿Including a hashtag gives your Tweet context and allows people to easily follow topics that they’re interested in.</li>
</ul>
</li>
</ul>
<p>@Mentions are used when talking to or about someone (the user account of a person, brand, group, etc.)</p>
<ul>
<li>﻿﻿In marketing</li>
<li>﻿﻿Using hashtags helps a brand connect with what’s happening on Twitter.<br> When brands connect with what’s happening on Twitter, they see</li>
<li>﻿﻿lifts across the marketing funnel, such as<ul>
<li>﻿﻿+18% message association, +8% brand awareness, and +3% purchase intent</li>
</ul>
</li>
</ul>
<h4 id="Twitter-REST-API"><a href="#Twitter-REST-API" class="headerlink" title="Twitter REST API"></a>Twitter REST API</h4><ul>
<li><p>﻿﻿The user Tweet timeline endpoint is a REST endpoint that receives a single path parameter to indicate the desired user (by user ID).</p>
<ul>
<li>﻿﻿The endpoint can return the 3,200 most recent<ul>
<li>﻿﻿Tweets, Retweets, replies, and Quote Tweets posted by the user.</li>
</ul>
</li>
</ul>
</li>
<li><p>﻿﻿User mention timeline</p>
<ul>
<li>﻿﻿The user mention timeline endpoint allows you to request Tweets</li>
<li>﻿﻿mentioning a specific Twitter user, for example,<ul>
<li>﻿﻿if a Twitter account mentioned @TwitterDev within a Tweet</li>
</ul>
</li>
</ul>
</li>
<li><p>it is possible to collect a huge amount of information regarding tweets, accounts, users’ timelines and social networks (i.e., following and followers).</p>
</li>
</ul>
<h4 id="Interaction-among-users"><a href="#Interaction-among-users" class="headerlink" title="Interaction among users"></a>Interaction among users</h4><ul>
<li>﻿﻿In order to understand the connections among users, it is important to consider not only their social networks<ul>
<li>﻿﻿but also, the way they interact, especially through retweets</li>
</ul>
</li>
<li>﻿﻿the Twitter API does not provide complete information about retweets and their propagation paths.<ul>
<li>﻿﻿More precisely, the only information carried by a retweet is the original user</li>
</ul>
</li>
<li>﻿﻿To estimate retweet cascade graphs,<ul>
<li>﻿﻿many strategies based on social network information</li>
<li>﻿﻿(i.e., friends and followers) in conjunction with temporal information</li>
</ul>
</li>
</ul>
<h4 id="Retweet-Graph"><a href="#Retweet-Graph" class="headerlink" title="Retweet Graph"></a>Retweet Graph</h4><ul>
<li><p>﻿﻿a graph of users, where an edge</p>
<ul>
<li>﻿﻿means that one of the users has retweeted a message of a different user.</li>
</ul>
</li>
<li><p>﻿﻿retweet graph G &#x3D; (V, E),</p>
<ul>
<li>﻿﻿which is a graph of users that have participated in the discussion on a specific topic.</li>
<li>﻿﻿A directed edge e &#x3D; (u, v) indicates that user v has retweeted a tweet of u.</li>
<li>﻿﻿Or e &#x3D; (u, v) indicates that user u has retweeted a tweet of v.</li>
</ul>
</li>
</ul>
<p>![image-20230430225752042](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230430225752042.png)</p>
<p>Count the number of links to a node in the network</p>
<ul>
<li>﻿﻿the number of directed edges with source (destination)</li>
<li>﻿﻿In-degree - number of retweets of a user<br> Out-degree - number of retweets this particular node (user)<br> made</li>
</ul>
<p>observe the retweet graph at the time instances t &#x3D; 0, 1, 2, . ..,</p>
<ul>
<li>﻿﻿where either a new node or a new edge was added to the graph,</li>
<li>﻿﻿G, &#x3D; (V+, Et) the retweet graph at time t</li>
</ul>
<p><strong>Issues in building interaction graph</strong></p>
<ul>
<li>﻿﻿prior studies exploited the fact that users tend to interact more often with newer tweets,<ul>
<li>﻿﻿and a user is more likely to retweet the last friend who retweeted content.</li>
</ul>
</li>
<li>﻿﻿However, this approach is no longer a reliable way of estimating retweet graphs,</li>
<li>﻿﻿Since, Twitter does not show content based on<ul>
<li>﻿﻿simple reverse chronological order,</li>
<li>﻿﻿but according to user interests, trending topics and interactions</li>
</ul>
</li>
<li>﻿﻿fetch all the required social network information.<ul>
<li>﻿﻿the time required to fetch all</li>
</ul>
</li>
<li>﻿﻿Due to the Twitter API rate limits, the time required to collect the list of friends and followers is<ul>
<li>﻿﻿six times greater with respect to downloading the user’s timeline on average.</li>
</ul>
</li>
</ul>
<p><strong>Some findings</strong></p>
<ul>
<li>﻿﻿analyse the spread mechanics of content through hashtag use</li>
<li>﻿﻿and derive probabilities that users adopt a hashtag.</li>
<li>﻿﻿Hash tags tend to travel to more distant parts of the network and</li>
<li>﻿﻿URLs travel shorter distances.</li>
</ul>
<p>Random graph model</p>
<ul>
<li>﻿﻿Super-star random graph node for a giant component of a retweet graph.</li>
<li>﻿﻿users with many retweets have a higher chance to be retweeted,</li>
<li>﻿﻿however, there is also a super- star node that receives a new retweet at each step with a positive probability.</li>
</ul>
<h3 id="Modellng-Trends"><a href="#Modellng-Trends" class="headerlink" title="Modellng Trends"></a>Modellng Trends</h3><ul>
<li>﻿﻿Trending topics<ul>
<li>﻿﻿Ongoing topics that become suddenly extremely popular</li>
</ul>
</li>
<li>﻿﻿detecting different types of trends, for instance<ul>
<li>﻿﻿detecting emergencies,</li>
<li>﻿﻿earthquakes,</li>
<li>﻿﻿diseases or important events in sports.</li>
</ul>
</li>
<li>﻿﻿An important part of trending behaviour in social media is</li>
<li>﻿﻿the way these trends progress through the network.</li>
</ul>
<h3 id="Two-options"><a href="#Two-options" class="headerlink" title="Two options"></a>Two options</h3><ul>
<li><p>﻿﻿Content of the tweets discussing a topic</p>
<ul>
<li>﻿﻿How do we find this?</li>
</ul>
</li>
<li><p>﻿﻿Underlying networks describing the social ties between users of<br> Twitter</p>
<ul>
<li>﻿﻿a graph of users, where an edge means that one of the users has retweeted a message of a different user.</li>
</ul>
</li>
<li><p>﻿﻿In both cases, we could ask</p>
<ul>
<li><p>﻿﻿How big or small interaction network compared to followers’ network?</p>
</li>
<li><p>What kind of information goes through the network?</p>
<ul>
<li>85% of content is&#x2F;was News!</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Largest-connected-component-LCC"><a href="#Largest-connected-component-LCC" class="headerlink" title="Largest connected component LCC"></a>Largest connected component LCC</h4><ul>
<li>LCC refers to a maximum set of nodes</li>
<li>such that you can move from any node to any other node</li>
<li>in this set by only moving between side-adjacent nodes from the graph.</li>
</ul>
<p>All components of a graph can be found by looping through its vertices,</p>
<p>starting a new breadth-first or depth-first search whenever the loop reaches a vertex that has not already been included in a previously found component.</p>
<p><strong>Graph density</strong></p>
<ul>
<li>﻿﻿represents the ratio between the edges present in a graph ﻿﻿and the maximum number of edges that the graph can contain.</li>
<li>﻿﻿Conceptually, it provides an idea of how dense a graph is in terms of edge connectivity.</li>
<li>﻿﻿In this work |E|&#x2F;|V|</li>
</ul>
<p><strong>size</strong> of the largest connected component (LCC) and its <strong>density</strong> are the most informative characteristics for predicting the peak in Twitter. </p>
<h4 id="Information-diffusion-amp-influencers"><a href="#Information-diffusion-amp-influencers" class="headerlink" title="Information diffusion &amp; influencers"></a>Information diffusion &amp; influencers</h4><p>Issue with retweet graph</p>
<ul>
<li><p>﻿﻿users might be exposed and influenced by a piece of information by multiple users, hence forming multiple influence paths</p>
</li>
<li><p>﻿﻿When a message arrives that is a retweet, every friend that has (re)tweeted at an earlier point in time ﻿﻿has to be considered as a potential influencer</p>
</li>
<li><p>﻿﻿there is no agreement on the minimum number of followers needed to be regarded as an “influencer”</p>
</li>
<li><p>﻿﻿In fact, in marketing, they talk about</p>
<ul>
<li>Micro-influencers</li>
</ul>
</li>
</ul>
<p><strong>Influence paths express the relationship of “who was influenced by whom”.</strong> </p>
<p>The set of influence paths form a social graph, that share a <strong>common root</strong> (a single user who first seeded a tweet). Influence path is referred as “information cascade”. A cascade is formed when users forward the same original message from a user that we call the root user.</p>
<p><strong>Information cascade model</strong></p>
<ul>
<li><p>﻿how information is being propagated from user to user from the stream of messages and the social graph.</p>
</li>
<li><p>﻿Nodes of the cascade represent users (user nodes) of the social network that got ﻿“influenced” by the root or another user.</p>
</li>
<li><p>﻿Edges of the cascade represent edges of the social graph over which influence actually spread.</p>
</li>
</ul>
<p><strong>An “influencer” in the case of Twitter is the so called “friend” that exposes information to his&#x2F;her followers and</strong></p>
<p>exerts influence on them in such a way that they forward this piece of information.</p>
<p>However, real data is missing?</p>
<p>we can derive these influence paths from these social connections among users.</p>
<p><strong>Absolute Interaction strength</strong></p>
<p>![image-20230501103443357](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230501103443357.png)</p>
<p><strong>Retweet distribution</strong> </p>
<ul>
<li>﻿﻿The retweet distribution given the time delay between the retweet action date and the original tweet posting time<ul>
<li>﻿﻿for 16,304 cascades</li>
</ul>
</li>
<li>Temporal dynamics of the retweets after the respective roottime</li>
<li>﻿﻿Showing a decreasing trend,<ul>
<li>﻿﻿as the highest number of interactions occurred</li>
<li>﻿﻿soon after roottime (the original tweet creation date).</li>
</ul>
</li>
</ul>
<p><strong>Weighted information strength</strong></p>
<p>![image-20230501103700956](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230501103700956.png)</p>
<p>![image-20230501103748922](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230501103748922.png)</p>
<p><strong>Approach - Generating Retweet Cascade Graphs</strong> </p>
<p>![image-20230501103852547](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230501103852547.png)</p>
<p><strong>No interaction</strong></p>
<p>![image-20230501103945037](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230501103945037.png)</p>
<p><strong>In addition</strong></p>
<ul>
<li>﻿﻿when there are no available interactions by a user u, and thus</li>
<li>﻿﻿no IS values between u and any other user,</li>
<li>﻿﻿An alternative is to find a link from the u to another user in the cascade</li>
<li>﻿﻿collect the user’s friend list by using the Twitter API, and</li>
<li>﻿﻿every user’s friend that has retweeted at an earlier point in time is considered as a potential influencer</li>
<li>﻿﻿To identify the influencer that more likely spread the tweet to user u,</li>
<li>﻿﻿consider the most recent influencer, i.e., u is linked to the last friend that retweeted the message.</li>
<li>﻿﻿Users that still remaining without an edge after this second step are denoted as sparse nodes<br> (SN).</li>
</ul>
<p><strong>How do you find influencer nodes and communities?</strong></p>
<ul>
<li>How could we find important nodes?<ul>
<li>Influencers?</li>
</ul>
</li>
<li>How can we find the information paths?<ul>
<li>What measures you may use? <strong>Centrality</strong>, <strong>Degrees</strong>.</li>
</ul>
</li>
<li>What alternative mechanisms to weight graphs?</li>
</ul>
<h3 id="L8-Network-Analysis-Case-studies-in-Health-Communities"><a href="#L8-Network-Analysis-Case-studies-in-Health-Communities" class="headerlink" title="L8 Network Analysis - Case studies in Health Communities"></a>L8 Network Analysis - Case studies in Health Communities</h3><h4 id="Case-studies"><a href="#Case-studies" class="headerlink" title="Case studies"></a>Case studies</h4><p>How online communities of people with long-term conditions function &amp; evolve: network analysis of the structure and dynamics of the asthma UK and British lung foundation online communities,</p>
<p><strong>Problems</strong></p>
<ul>
<li><p>﻿﻿We have seen</p>
<ul>
<li><p>﻿﻿People express themselves through social media</p>
</li>
<li><p>﻿﻿Huge amount of data</p>
</li>
</ul>
</li>
<li><p>﻿﻿People suffering from mental health</p>
<ul>
<li>﻿﻿Silent suffering!</li>
</ul>
</li>
<li><p>﻿﻿Can we create a self-management or self-diagnosis tool</p>
<ul>
<li><p>﻿﻿A tool helping them to control their situation</p>
</li>
<li><p>﻿﻿A tool nudging them to get help!!</p>
</li>
</ul>
</li>
<li><p>﻿﻿To start with</p>
<ul>
<li>﻿﻿How prevalent is mental health issues in society?</li>
</ul>
</li>
<li><p>﻿﻿Can we mine network structure of social media to understand how communities support mental health issues?</p>
<ul>
<li>﻿﻿Network structure of social media data provide insights on support given by society on mental health issues</li>
</ul>
</li>
</ul>
<p><strong>Social Support</strong></p>
<p>Social Support is an exchange of resources between two individuals</p>
<ul>
<li><p>﻿﻿perceived by the provider or the recipient to be intended</p>
</li>
<li><p>﻿﻿to enhance the well-being of the recipient</p>
<ul>
<li><p>﻿﻿e.g.,</p>
<ul>
<li><p>﻿﻿Facebook interaction</p>
</li>
<li><p>﻿﻿RTs …</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>How to extract signatures of perceived social support?</p>
<p><strong>Post-reply Network</strong></p>
<p>Example -&gt; StackOverflow</p>
<p>It is not like twitter, its form is due to the users shared same interest.</p>
<p>A community expertise network.</p>
<h4 id="Graph-modelling-WHAT-IS-INTERACTION-GRAPH"><a href="#Graph-modelling-WHAT-IS-INTERACTION-GRAPH" class="headerlink" title="Graph modelling WHAT IS INTERACTION GRAPH"></a><strong>Graph modelling WHAT IS INTERACTION GRAPH</strong></h4><p><strong>User interaction graph</strong></p>
<p>Tie</p>
<ul>
<li><p>﻿﻿Tie connect a pair of users&#x2F;actors by one or more relations</p>
<ul>
<li><p>﻿﻿Sharing information, financial or Psychological support</p>
</li>
<li><p>﻿﻿One relation or multiple set of relations</p>
</li>
<li><p>﻿﻿Vary in content, direction &amp; strength</p>
</li>
</ul>
</li>
<li><p>﻿﻿look at the actual tie between users instead of message level interactions</p>
</li>
</ul>
<p><strong>Structural prestige in online communities</strong></p>
<ul>
<li><p>﻿﻿A thread</p>
<ul>
<li>How many people a user replied (out degree!!)</li>
<li>﻿﻿How many people replied to the user (in degree!!)</li>
</ul>
</li>
<li><p>﻿﻿In directed networks</p>
<ul>
<li><p>﻿﻿People who send many responses&#x2F;replies</p>
</li>
<li><p>﻿﻿are considered to be prestigious</p>
</li>
<li><p>﻿﻿Or person with knowledge</p>
</li>
</ul>
</li>
</ul>
<p><strong>Size of a node</strong></p>
<ul>
<li>﻿﻿the size of the node depends on the number of replies send by the user</li>
<li>﻿﻿The more the number of replies, the larger the node</li>
</ul>
<p><strong>How to create an interaction graph?</strong></p>
<ul>
<li><p>﻿﻿the users who post and the corresponding reply users</p>
</li>
<li><p>﻿﻿A Pandas DataFrame contains two columns of node names</p>
<ul>
<li>﻿﻿posts_author, comments_author.</li>
</ul>
</li>
<li><p>﻿﻿use nx.from pandas_ edgelist() to transfer the DataFrame to a network graph.</p>
<ul>
<li><p>﻿﻿Network (NX) is a python software package,</p>
</li>
<li><p>﻿﻿used to create and operate complex networks,</p>
</li>
<li><p>﻿﻿and to learn the structure, dynamics and functions of complex networks.</p>
</li>
</ul>
</li>
<li><p>﻿﻿To distinguish the importance of each user who post,</p>
<ul>
<li><p>﻿﻿we set the size of these users’ to twice its node degree<br> User’s node orange</p>
</li>
<li><p>﻿﻿Replies node to light gray the directed edges to light blue colour.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Temporal activity patterns</strong></p>
<ul>
<li>Let us study how the community thrive?<ul>
<li>How do they function and evolve over time?</li>
</ul>
</li>
<li>Basically we are answering research questions <ul>
<li>like “ what is the basic structure of SUCH online communities and how do they function and evolve over time”</li>
</ul>
</li>
</ul>
<p><strong>Degree distributions</strong></p>
<ul>
<li><p>﻿﻿Look at the distribution of degrees,</p>
</li>
<li><p>﻿﻿Or the amount of edges a node has</p>
</li>
<li><p>﻿﻿Acros sall nodes in a graph</p>
</li>
<li><p>﻿﻿Top 1% of nodes</p>
<ul>
<li><p>﻿﻿in terms of degrees</p>
</li>
<li><p>﻿﻿most interactive and have<br> Established edges with a lot of other users by exchanging messages</p>
</li>
<li><p>﻿﻿Known as super users,</p>
</li>
</ul>
</li>
</ul>
<p><strong>Activity analysis</strong></p>
<ul>
<li><p>﻿﻿How are users engaging or community thrive?</p>
<ul>
<li>﻿﻿Does posting activity follow a time pattern?</li>
</ul>
</li>
<li><p>﻿﻿How many activity is happening on a daily or weekly basis on a particular community</p>
<ul>
<li><p>﻿﻿Number of messages exchanged in a community across the whole life cycle of data</p>
</li>
<li><p>﻿﻿how users engaging with a community</p>
</li>
</ul>
</li>
<li><p>﻿﻿Cumulative frequencies of activity</p>
<ul>
<li>﻿﻿Number of posts reply per week</li>
</ul>
</li>
</ul>
<p><strong>To understand the behaviour of the community</strong></p>
<ul>
<li><p>the trend tends to be linear,</p>
<ul>
<li>which indicates that the number of new replies per week remains stable.</li>
</ul>
</li>
<li><p>SuicideWatch, average 211605 posts to come weekly and PSTD average 1980 posts</p>
</li>
<li><p>This shows that the average weekly posting volume of Suicide Watch community users is almost 100 times that of PTSD.</p>
<ul>
<li>227,307 users in the SuicideWatch community, while PTSD has only 50032 users,</li>
</ul>
</li>
</ul>
<p><strong>Open question – how do we distinguish two communities?</strong></p>
<p>Modularity Optimization: Modularity is a measure of the degree to which nodes in a network are connected within their own community compared to the connections between different communities. Modularity optimization involves identifying communities that maximize modularity, or in other words, communities that have a high degree of internal connections and a low degree of external connections.</p>
<p>Girvan-Newman Algorithm: This algorithm involves iteratively removing edges from the network in order of their “betweenness centrality,” which is a measure of how often a given edge lies on the shortest path between two nodes. By removing edges in this way, the algorithm gradually breaks the network into smaller and smaller communities.</p>
<p>Label Propagation: This method involves assigning an initial label to each node in the network and then iteratively updating the labels based on the labels of neighboring nodes. Over time, nodes tend to cluster into groups with similar labels, forming communities.</p>
<p>Spectral Clustering: This method involves using the eigenvalues and eigenvectors of the network’s adjacency matrix to identify communities. By projecting the network onto a lower-dimensional space, spectral clustering can often separate nodes into distinct communities.</p>
<p> <strong>how did we study the behaviour of two communities &amp; what did we found?</strong></p>
<ul>
<li><p>﻿﻿For each week</p>
</li>
<li><p>﻿﻿Compute average post</p>
<ul>
<li><p>﻿﻿Look at the total posts by all users</p>
</li>
<li><p>﻿﻿Divided by total number of unique users</p>
</li>
</ul>
</li>
<li><p>﻿﻿How users are engaging with the community?</p>
<ul>
<li><p>﻿﻿A continuous engagement is good for the vitality of community.</p>
</li>
<li><p>﻿﻿Do these communities drive enough engagement and activity to sustain</p>
</li>
</ul>
</li>
</ul>
<p><strong>Super users</strong></p>
<ul>
<li><p>﻿﻿A small minority of users</p>
<ul>
<li><p>﻿﻿Responsible for a high proportion of posting activity and thus support</p>
</li>
<li><p>﻿﻿Functioning of communities</p>
</li>
</ul>
</li>
<li><p>﻿﻿5% of users generate</p>
<ul>
<li>﻿﻿Over 70% of content</li>
</ul>
</li>
<li><p>﻿How do we study the role of super users?</p>
<ul>
<li>﻿﻿Sensitivity analysis</li>
</ul>
</li>
</ul>
<p><strong>How to find the super user?</strong></p>
<ul>
<li><p>﻿﻿For each user</p>
<ul>
<li><p>﻿﻿Count the number of posts (A) and</p>
</li>
<li><p>﻿﻿The number of replies (B)</p>
</li>
<li><p>﻿﻿The number of total activity (A + B)</p>
</li>
</ul>
</li>
<li><p>﻿﻿Rank the user in terms of respective frequencies</p>
</li>
</ul>
<p><strong>Connected component</strong></p>
<ul>
<li>﻿﻿A connected component of an undirected graph is a maximal set of nodes such that<ul>
<li>﻿﻿each pair of nodes is connected by a path.</li>
</ul>
</li>
<li>﻿﻿Directed graphs have weakly and strongly connected components.</li>
<li>﻿﻿Two vertices are in the same weakly connected<br> component<ul>
<li>﻿﻿if they are connected by a path, where paths are allowed to go either way along any edge.</li>
</ul>
</li>
<li>﻿﻿The weakly connected components correspond closely to the concept of connected component in undirected graphs and the typical situation is similar<ul>
<li>﻿﻿there is usually one large weakly connected component plus other small ones.</li>
</ul>
</li>
</ul>
<p><strong>Largest connected component</strong></p>
<ul>
<li><p>﻿﻿A largest connected component of a</p>
<ul>
<li><p>﻿﻿Graph G(V,E) is the largest possible subgraph</p>
<ul>
<li><p>﻿G_L(V_L,E_L) of G,</p>
</li>
<li><p>﻿﻿such that each node in G_L, has at least one valid connected path to every other node in G_L,</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>﻿﻿LCC gives us the subset of users</p>
<ul>
<li>﻿﻿Who form a cohesive community</li>
</ul>
</li>
<li><p>﻿﻿Importance of super users on LCC</p>
<ul>
<li>﻿﻿By removing them and studying the cohesion</li>
</ul>
</li>
</ul>
<p><strong>Community resilience</strong></p>
<p>Temporal Analysis</p>
<ul>
<li><p>﻿﻿Characteristics of LCC on a weekly basis</p>
</li>
<li><p>﻿﻿Focused and cohesive nature of interactions</p>
<ul>
<li>﻿﻿By looking at the fraction of users belonging to the LCC.</li>
</ul>
</li>
<li><p>﻿﻿Our aim is to study</p>
<ul>
<li>﻿﻿community resilience</li>
</ul>
</li>
<li><p>﻿﻿First how cohesive</p>
<ul>
<li>﻿﻿The community is?</li>
</ul>
</li>
<li><p>﻿﻿For each weekly graph, G</p>
<ul>
<li><p>﻿﻿Compute the LCC</p>
</li>
<li><p>﻿﻿That is all nodes in LCC has at least one path</p>
</li>
</ul>
</li>
<li><p>﻿﻿Compute fraction N&#x2F;N</p>
<ul>
<li>﻿﻿Nk is the nodes in LCC</li>
</ul>
</li>
</ul>
<p><strong>Fragility of the community</strong></p>
<ul>
<li><p>﻿﻿If the conversation network is held by</p>
<ul>
<li><p>﻿﻿A more or less uniform contribution of nodes</p>
</li>
<li><p>﻿﻿Or</p>
</li>
<li><p>﻿﻿Is there a skew in the responsibility of nodes</p>
</li>
</ul>
</li>
<li><p>﻿﻿Sensitivity analysis methods</p>
<ul>
<li>﻿﻿Which measures the network’s capacity to diffuse information as you move nodes based on certain property</li>
</ul>
</li>
<li><p>﻿﻿Importance of super users</p>
</li>
</ul>
<p><strong>Sensitivity analysis</strong></p>
<ul>
<li>﻿﻿the targeted removal of nodes (users) starting from the most connected nodes.</li>
<li>﻿﻿represents the size of the largest component as a percentage of the network size.</li>
<li>﻿﻿Specifically, it illustrates the key effects of the superusers on the website from another perspective.</li>
</ul>
<p><strong>Rich club effect</strong></p>
<ul>
<li><p>﻿﻿that a few important nodes (users) show stronger and closer connection with each other,</p>
<ul>
<li>﻿﻿and constitute a structural core and functional hub.</li>
</ul>
</li>
<li><p>﻿﻿the rich-club coefficient</p>
<ul>
<li>is the ratio of the actual number of edges of nodes with order greater than k</li>
<li>﻿﻿to the number of potential edges of each order k</li>
</ul>
</li>
</ul>
<p>![image-20230501161132105](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230501161132105.png)</p>
<ul>
<li>the coefficient continues to be lower than 1,<ul>
<li>indicating that the amount of interaction between superusers are not high, </li>
<li>the amount of interactions between most non-superusers are also not high.</li>
</ul>
</li>
<li>the interactions between the superusers and non-superusers are very high,<ul>
<li>indicating that superusers are more inclined to communicate with users with fewer interactive connections.</li>
</ul>
</li>
<li>How do we explain this<ul>
<li>there are a large number of users with purposeful questions on the website and a small number of experts in the field.</li>
</ul>
</li>
</ul>
<h4 id="Z-score"><a href="#Z-score" class="headerlink" title="Z-score"></a>Z-score</h4><ul>
<li><p>﻿﻿We have seen core users and their relationship with other users from the graph</p>
</li>
<li><p>﻿﻿We do not know whether core users</p>
<ul>
<li><p>﻿﻿Tend to ask for help (post more)</p>
</li>
<li><p>﻿﻿Help others (reply more</p>
</li>
</ul>
</li>
<li><p>﻿﻿Look at a thread!</p>
</li>
<li><p>﻿﻿To find that out let us look at z-score!!<br>z &#x3D; (х - mean)&#x2F;sd</p>
</li>
</ul>
<h4 id><a href="#" class="headerlink" title></a></h4><h2 id="Emotion-Analysis"><a href="#Emotion-Analysis" class="headerlink" title="Emotion Analysis"></a>Emotion Analysis</h2><h3 id="L9"><a href="#L9" class="headerlink" title="L9"></a>L9</h3><h4 id="Sentiment-analysis-amp-variants"><a href="#Sentiment-analysis-amp-variants" class="headerlink" title="Sentiment analysis &amp; variants"></a>Sentiment analysis &amp; variants</h4><p><strong>Variants</strong></p>
<ul>
<li>﻿﻿<strong>Sentiment classification</strong><ul>
<li>﻿﻿whether a piece of text is positive, negative or neutral</li>
<li>﻿﻿Degree of intensity<ul>
<li>﻿﻿[-100,100]</li>
</ul>
</li>
</ul>
</li>
<li>﻿﻿Opinion analysis<ul>
<li>Determining from text, the speaker’s opinion and target of the opinion</li>
</ul>
</li>
<li>﻿﻿Stance<ul>
<li>﻿﻿Author of text is in favour of, against of, or neutral towards a proposition or target</li>
<li>﻿﻿For example, Brexit agreement<ul>
<li>﻿﻿Is people supportive?</li>
</ul>
</li>
</ul>
</li>
<li>﻿﻿<strong>Emotion</strong><ul>
<li>﻿﻿What are the emotion expressed in the text?</li>
</ul>
</li>
</ul>
<p><strong>Sentiment vs Stance</strong></p>
<ul>
<li>﻿﻿Target:<ul>
<li>﻿﻿Legalization of Abortion</li>
</ul>
</li>
<li>﻿﻿Tweet<ul>
<li>The pregnant are more than walking incubators. They have rights too!</li>
<li>﻿﻿In favour of the target</li>
<li>﻿﻿Target - Pro-life movement<ul>
<li>﻿??</li>
</ul>
</li>
</ul>
</li>
<li>﻿﻿Target<ul>
<li>﻿﻿Donald Trump</li>
</ul>
</li>
<li>﻿﻿Tweet<ul>
<li>﻿﻿Donald Trump has some strengths and some weakness<ul>
<li>neutral</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Stance detection</strong></p>
<ul>
<li>﻿﻿Is the task of automatically determining from text<ul>
<li>﻿﻿whether the author of the text is in favour of, against of, or neutral</li>
<li>﻿﻿toward a proposition or target</li>
</ul>
</li>
<li>﻿﻿Target<ul>
<li>﻿﻿Person, organization, government policy, a movement, a product</li>
<li>﻿﻿E.g., infer from former Prime minister Boris Jonson’s speeches that he is in favour of Brexit</li>
<li>﻿﻿E.g., analysing tweets identify people in favour of leadership change</li>
</ul>
</li>
</ul>
<p>Aspect Based Sentiment Analysis</p>
<ul>
<li>﻿﻿A sentence contains one or more entities,<ul>
<li>﻿﻿each of which has a different polarity of emotion.</li>
</ul>
</li>
<li>﻿﻿For example, give a comment like<ul>
<li>﻿﻿“Great food but the service is dreadful!”,</li>
<li>﻿﻿the emotional polarity of entity “food” is “positive”</li>
<li>﻿﻿while the emotional polarity of entity “service” is “negative”.</li>
</ul>
</li>
<li>﻿﻿Compared to sentence level sentiment analysis, ABSA can present<ul>
<li>﻿﻿users with more precise and fine-grained sentiment information of entities</li>
</ul>
</li>
<li>﻿﻿You identify an aspect and the sentiment towards that aspect</li>
</ul>
<p><strong>Sentiment classifification is limited</strong></p>
<ul>
<li>﻿﻿Language serves social and interpersonal functions.<ul>
<li>﻿﻿Affective meaning is key for human interaction and a prominent characteristic of language use.</li>
</ul>
</li>
<li>﻿﻿This extends beyond<ul>
<li>﻿﻿opinions vs. factual or polarity distinctions</li>
<li>﻿﻿into multiple phenomena:<ul>
<li>﻿﻿emotion, mood, personality, attitude, credibility, volition, veracity, friendliness, etc.</li>
</ul>
</li>
</ul>
</li>
<li>﻿﻿<strong>Emotion:</strong><ul>
<li>﻿﻿angry, sad, joyful, fearful, …</li>
</ul>
</li>
<li>﻿﻿recognition, characterization, or generation of affect states,<ul>
<li>﻿﻿involves analysis of affect-related conditions, experiences, and activities.</li>
</ul>
</li>
</ul>
<p><strong>Textual emotion</strong></p>
<ul>
<li>﻿﻿We analyse the text and detect the emotion<ul>
<li>﻿﻿expressed by the author or</li>
<li>﻿﻿the emotion potentially felt by the reader</li>
</ul>
</li>
<li>﻿﻿Linguistic sensing of affective states can be used for<ul>
<li>﻿﻿Understanding social issues expressed through social media</li>
</ul>
</li>
<li>﻿﻿Researchers in psychological science believe that<ul>
<li>﻿﻿individuals have internal mechanisms for a limited collection of responses, usually</li>
<li>﻿﻿happy, sad, anger, disgust, and fear</li>
</ul>
</li>
</ul>
<p><strong>There are 6 emoMon categories that are widely used to describe</strong> </p>
<p>humans’ basic emoMons, based on facial expression: </p>
<p><strong>anger, disgust, fear,</strong> <strong>happiness</strong>, <strong>sadness</strong> and <strong>surprise</strong>.</p>
<ul>
<li>Categorical theories</li>
<li>EmoIons are discretely and difffferently constructed and</li>
<li>all humans are thought to have an innate set of basic emoIon </li>
<li>that are cross-culturally recognisable</li>
</ul>
<p><strong>OCC model</strong></p>
<p>22 emotions &#x3D; 6 Paul Ekman emotions + 16 addtional emotions</p>
<p><strong>Criticism</strong></p>
<ul>
<li>In the categorical approach, emotional states are restricted to a limited number of distinct types and</li>
<li>it can be difficult to resolve a complex emotional situation or mixed emotions.</li>
<li>Appraisal theory</li>
<li>It contains componential emotion models based on the theory of appraisal.</li>
<li>Appraisal theory describes how different emotions, in various participants and on different times, can arise from the same event</li>
</ul>
<h4 id="Text-emotion-detection"><a href="#Text-emotion-detection" class="headerlink" title="Text emotion detection"></a>Text emotion detection</h4><p><strong>motivation</strong></p>
<ul>
<li>﻿﻿because of the naturally vague and ambiguous human language is,<ul>
<li>﻿﻿the emotion detection can be highly “context-sensitive and complex”</li>
</ul>
</li>
<li>﻿﻿Emotion analysis is a convoluted task, even for human beings,<ul>
<li>﻿﻿due to the various cultures, gender, and context of people who authored the texts.</li>
<li>﻿﻿The task will be much easier when emotion is expressed explicitly, but in reality,</li>
<li>﻿﻿the majority of texts are subtle, ambiguous, and some words have more than one meaning, and</li>
<li>﻿﻿more than one word expresses the same emotions, and, in addition, some emotions can exist simultaneously</li>
</ul>
</li>
<li>﻿﻿Don’t u just HATE it when u cannot find something that u know you just saw like<br> 10 min ago!</li>
<li>By analysing the horse racing comments,</li>
<li>﻿﻿the model can learn about the information of winning horse and</li>
<li>﻿﻿would be able to give a reasonable prediction based on the emotion.</li>
</ul>
<p><strong>emotion classification</strong></p>
<ul>
<li>﻿﻿In the case of sentiment analysis, this task can be tackled using<ul>
<li>﻿﻿lexicon-based methods, machine learning, or a reule-based approach</li>
</ul>
</li>
<li>﻿﻿In emotion recognition task, the 4 most common approaches are<ul>
<li>﻿﻿Keyword-based detection<ul>
<li>﻿﻿Seed opinion words and find synonyms &amp; antonyms in WordNet</li>
<li>﻿﻿WordNet</li>
</ul>
</li>
</ul>
</li>
<li>﻿﻿Lexical affinity</li>
<li>﻿﻿hybrid</li>
<li>﻿﻿Learning based detection</li>
</ul>
<p><strong>Lexicon</strong></p>
<ul>
<li>﻿﻿Lexicons are linguistic tools for automated analysis of text</li>
<li>﻿﻿Most common<ul>
<li>﻿﻿Simple list of terms associated to a certain class of interest</li>
<li>﻿﻿Classification by counting</li>
<li>﻿﻿Terms can be weighted according to their strength of association with a given class</li>
</ul>
</li>
</ul>
<p>Lexicon based approaches?</p>
<ul>
<li>﻿﻿“I love horror books”</li>
<li>﻿﻿f(love) × 1.0 + f(horror) x 0.3 + f(books) x 0.5 &#x3D; 1.8 for positive</li>
<li>﻿﻿f(love) x 0.0 + f(horror) x 0.7 + f(books) × 0.5 &#x3D; 1.2 for negative</li>
<li>﻿﻿Decision function<ul>
<li>﻿﻿Classify one with maximum value</li>
</ul>
</li>
<li>Transparency<ul>
<li>﻿﻿Each prediction can be explained<ul>
<li>﻿﻿Analysing terms that were present in the text</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>BERT VS gpt</strong></p>
<h1 id="Mock-Paper"><a href="#Mock-Paper" class="headerlink" title="Mock Paper"></a>Mock Paper</h1><h2 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h2><ol>
<li></li>
</ol>
<p>(a) Assume that the BBC recruited you to develop a social media application. The BBC is interested in knowing their readers’ feelings on the news and other events covered by the broadcaster. Your job is to develop a classifier. In this context, answer the following questions:</p>
<p>(i)</p>
<p>Your first task is to create Twitter datasets with positive and negative statements so that they can be used for estimating the probabilities for words in the respective classes. [Hint: Assuming that you have a social media crawler, discuss how you will automatically label positive and negative tweets; how will you avoid spurious data]</p>
<p><strong>use hashtag based data collection</strong></p>
<p>1.Data collection: Use a social media crawler to collect tweets that mention the BBC or are in response to BBC’s tweets. This could be done using Twitter’s API to search for tweets containing specific keywords, hashtags, or mentions related to BBC’s news and events.</p>
<p>2.Pre-process: Clean the collected tweets by removing irrelevant information such as URLs, mentions, and special characters. Convert all text to lowercase and tokenize the words for easier analysis. <strong>Ignore this step</strong>.</p>
<p>3.Automatic labeling: Loop the tweets, using lexicon approach to compute the overall score of a tweet. if a tweet has been annotated with a hashtag, then use NRC hashtag lexicon approach to label the tweet, if it has a emoji at the end then use emoticons based approach to label the tweet. Then calculate the score for each feature (word&#x2F;hashtag&#x2F;emoticon), select the label correspondingly based on overall score.</p>
<p>![image-20230501223242594](..&#x2F;images&#x2F;webs&#x2F;:Users:joshua:Library:Application Support:typora-user-images:image-20230501223242594.png)</p>
<p>4.Avoid spurious data. Pre-defined relevant hashtags: Compile a list of relevant and meaningful hashtags associated with the BBC or specific news and events covered by the broadcaster. Only collect and analyze tweets containing these pre-defined hashtags to ensure high-quality data. Noise filtering: Filter out tweets that are ambiguous, contain sarcasm, or are irrelevant to the BBC’s content. This can be done using advanced NLP techniques or by setting a minimum sentiment score threshold to exclude borderline cases.</p>
<p>(ii)</p>
<p>Your second task is to develop a lexicon-based automatic sentiment analysis method, which assigns sentiment intensity between [-100,100].Describe an algorithm that also uses the dataset you created in (i). [Hint: identify a suitable lexicon; identify linguistic cases you may handle; specify a scoring method] </p>
<p>To develop a lexicon-based automatic sentiment analysis method that assigns sentiment intensity between [-100, 100], follow these steps:</p>
<ol>
<li><p>Choose a suitable lexicon: Select a pre-built sentiment lexicon that provides sentiment scores for words. Examples of such lexicons include SentiWordNet, AFINN, or VADER. These lexicons typically assign sentiment scores to words on a scale of -1 to 1 or -5 to 5.</p>
</li>
<li><p>Preprocessing: Clean the dataset created in step (i) by removing irrelevant information like URLs, mentions, and special characters. Convert all text to lowercase and tokenize the words for easier analysis.</p>
</li>
<li><p>Handling linguistic cases: Address various linguistic cases to improve sentiment analysis:</p>
<p>a. Negations: Identify negation words (e.g., not, never, isn’t) and modify the sentiment score of the words that follow. For example, you can reverse or reduce the sentiment score of the word following the negation.</p>
<p>b. Intensifiers: Identify intensifier words (e.g., very, extremely, really) and adjust the sentiment score of the following word accordingly. For example, you can multiply the sentiment score by a factor (e.g., 1.5 or 2) based on the intensity of the intensifier.</p>
<p>c. Diminishers: Identify diminisher words (e.g., slightly, barely, hardly) and adjust the sentiment score of the following word accordingly. For example, you can multiply the sentiment score by a factor (e.g., 0.5) based on the diminishing effect.</p>
</li>
<li><p>Scoring method: Implement a scoring method to calculate the sentiment intensity of each tweet using the lexicon and linguistic cases:</p>
<p>a. Initialize a sentiment score variable to 0 for each tweet.</p>
<p>b. Iterate through the words in the tweet, and for each word, check if it has a sentiment score in the lexicon.</p>
<p>c. If the word has a sentiment score, adjust the score based on the linguistic cases (negations, intensifiers, diminishers) if applicable.</p>
<p>d. Add the sentiment score of the word to the tweet’s sentiment score.</p>
<p>e. After processing all words, normalize the tweet’s sentiment score to fit the range of [-100, 100]. For example, if the lexicon’s sentiment scores range from -5 to 5, multiply the tweet’s sentiment score by 20.</p>
<p>f. Assign the normalized sentiment score to the tweet as its sentiment intensity.</p>
</li>
<li><p>Evaluation: Compare the sentiment intensity assigned by the lexicon-based method with the labels in the dataset created in step (i). Calculate performance metrics such as accuracy, precision, recall, and F1-score to evaluate the effectiveness of the lexicon-based sentiment analysis method.</p>
</li>
</ol>
<p>By following these steps, you can develop a lexicon-based automatic sentiment analysis method that assigns sentiment intensity between [-100, 100] and uses the dataset created in the previous task.</p>
<p>(iii)</p>
<p>Now that you created a sentiment analysis method, you want to verify the method’s validity from a user’s perspective. Design a scalable user-based study to ensure your sentiment scoring method is appropriate.</p>
<p>To design a scalable user-based study to ensure the sentiment scoring method’s appropriateness, follow these steps:</p>
<ol>
<li>Select a representative sample: Randomly sample a subset of tweets from the dataset created in the first task. Make sure the sample includes a balanced number of positive and negative tweets, as well as a diverse range of topics covered by the BBC.</li>
<li>Prepare the evaluation interface: Develop a user-friendly interface for the study participants. The interface should display a tweet and its corresponding sentiment score, calculated using the lexicon-based sentiment analysis method. Participants should be able to rate the sentiment score’s appropriateness on a scale (e.g., 1 to 5, with 1 being “strongly disagree” and 5 being “strongly agree”).</li>
<li>Recruit participants: Recruit a diverse group of participants to ensure a broad range of perspectives. You can use platforms like Amazon Mechanical Turk, Prolific, or other crowdsourcing services to recruit participants on a large scale.</li>
<li>Training and instructions: Provide clear instructions and examples to participants on how to evaluate the sentiment scores. Briefly explain the concept of sentiment analysis, the scoring range of [-100, 100], and the evaluation scale. You may also provide examples of tweets with appropriate and inappropriate sentiment scores to help participants understand the task better.</li>
<li>Evaluation process: Ask participants to evaluate the sentiment scores of the sampled tweets using the provided interface. Encourage them to consider the context of the tweet and the sentiment score’s appropriateness based on the tweet’s content.</li>
<li>Collect user feedback: Allow participants to provide qualitative feedback on the sentiment scoring method, highlighting any issues or suggestions for improvement. This feedback can help identify potential areas of refinement for the sentiment analysis method.</li>
<li>Analyze results: After collecting the evaluations, calculate the average appropriateness score for each tweet’s sentiment score. High average scores indicate that the sentiment scoring method is appropriate from the user’s perspective. Analyze the qualitative feedback to identify common themes and potential areas for improvement.</li>
<li>Iterate and improve: Based on the study results, refine the sentiment analysis method to address identified issues and incorporate user feedback. Repeat the user-based study with the updated method to evaluate its effectiveness iteratively.</li>
</ol>
<p>By designing and conducting a scalable user-based study, you can ensure that the sentiment scoring method is appropriate from the user’s perspective and make data-driven improvements to enhance its accuracy and effectiveness.</p>
<ol start="2">
<li></li>
</ol>
<p>(a)Create a vector representation for the following short text. Identify and remove potential stop words. “@AlanStainer @takeitev It’s mad isn’t it. In the UK there are 8k petrol stations with multiple pumps and 25k chargers (increasing by 300 pm). They do know the climate emergency is now right? Not in 30 years’ time, Just asking”</p>
<p>Stopwords: “the”, “in”, “and”</p>
<p>[“it’s”, “mad”, “isn’t”, “uk”, “8k”, “petrol”, “stations”, “multiple”, “pumps”, “25k”, “chargers”, “increasing”, “300”, “pm”, “know”, “climate”, “emergency”, “right”, “30”, “years’”, “time”, “asking”]</p>
<p>(b)Create all biterms from the following text, “in the UK there are 8k petrol stations with multiple pumps and 25k chargers</p>
<p>(“in”, “the”) (“in”, “UK”) (“in”, “there”) … (“pumps”, “and”) (“pumps”, “25k”) (“pumps”, “chargers”) … (“and”, “25k”) (“and”, “chargers”) … (“25k”, “chargers”)</p>
<p>(c) Assume you have developed a topic model on a collection with your university communications for the last academic year. Design a user-centred experiment to evaluate the interpretability of the model. [Hint: design tasks and justify, selection of subjects, number of users, what will you measure, how do you prove the results]</p>
<p>Designing a user-centered experiment to evaluate the interpretability of a topic model involves several components, including selecting subjects, designing tasks, determining the number of users, and measuring performance. Here’s an outline for such an experiment:</p>
<ol>
<li><p>Define the goal: The primary goal of the experiment is to evaluate the interpretability of the topic model in terms of the coherence and relevance of the identified topics within the context of university communications.</p>
</li>
<li><p>Selection of subjects: Choose participants who have some familiarity with the university environment, such as students, faculty, and administrative staff. This will ensure that they can understand and assess the relevance of the topics generated by the model.</p>
</li>
<li><p>Number of users: To ensure the results are reliable and generalizable, aim for a diverse sample of participants. A sample size of 30-50 participants is typically considered sufficient for user-centered experiments, but the optimal number may vary depending on factors such as the complexity of the tasks and the desired statistical power.</p>
</li>
<li><p>Design tasks: Create tasks that help assess the interpretability of the topics generated by the model. Example tasks include:</p>
<p>a. Topic labeling: Ask participants to assign meaningful labels to a given set of topics. This assesses whether users can understand and make sense of the topics generated by the model.</p>
<p>b. Topic ranking: Ask participants to rank a list of topics based on their relevance or importance to the university’s communications. This helps evaluate the model’s ability to identify meaningful and relevant topics.</p>
<p>c. Document-topic assignment: Provide participants with a set of documents and ask them to assign the most relevant topic from the model to each document. This task assesses whether users can effectively map the generated topics to real-world documents.</p>
</li>
<li><p>Measurement: Collect quantitative and qualitative data to evaluate the interpretability of the model.</p>
<p>a. Quantitative measures: Calculate agreement scores (e.g., Fleiss’ Kappa or Cohen’s Kappa) to measure the consistency among participants in terms of topic labeling, ranking, and document-topic assignments.</p>
<p>b. Qualitative measures: Collect subjective feedback from participants about the coherence, relevance, and overall interpretability of the topics. This can be done through open-ended questions, interviews, or questionnaires.</p>
</li>
<li><p>Analyze results: Analyze the quantitative and qualitative data to assess the interpretability of the model. High agreement scores and positive feedback from participants would indicate that the model generates interpretable topics.</p>
</li>
<li><p>Prove the results: To prove the results, compare the performance of the topic model with alternative models or baseline approaches (e.g., LDA, NMF). Conduct a similar user-centered experiment for the alternative models and compare the agreement scores and subjective feedback. A higher performance of the developed topic model compared to the alternatives would provide evidence for its interpretability.</p>
</li>
</ol>
<p>By carefully designing and executing a user-centered experiment, you can evaluate the interpretability of a topic model in the context of university communications, ensuring that the model generates meaningful and relevant topics for the users.</p>
<p>(d)You have collected tweets and newspaper articles from Scotland for the last month.</p>
<p>Describe a method to develop topic models from these datasets. [Hint identify issues in dealing with such heterogenous datasets; how would you handle such issues]</p>
<p>l Prepare the tweets data, Pre-process of the data. </p>
<p>l Create a bigram model and trigram model. Then use the data with bigrams and trigrams to create the dictionary which will be used in model training.</p>
<p>l Use dictionary to create the corpus.</p>
<p>l Use LDA model to run topic modelling by the previous data which has been processed.</p>
<p>l Use different measures which including KL divergence, perplexity, and coherence to evaluate the model. This step will also help us to determine the number of topics.</p>
<p>l Update the model parameter by the result of evaluation.</p>
<p>l Visualize the model. The topic keywords will be displayed by a chart or a word cloud.</p>
<p><strong>Handling heterogeneity:</strong> Tweets and newspaper articles have different lengths, styles, and contexts. To address these issues:</p>
<p>a. Length normalization: To mitigate the differences in length between tweets and newspaper articles, consider using techniques like document sampling or text chunking. For instance, divide newspaper articles into smaller chunks of approximately the same size as tweets.</p>
<p>b. Text representation: Use a suitable text representation method that can capture the context and semantics of both short and long texts. Techniques like TF-IDF, word embeddings (e.g., Word2Vec, GloVe), or even more advanced methods like BERT embeddings can be used.</p>
<p>c. Combining datasets: Combine the preprocessed tweets and newspaper article chunks into a single dataset to build a unified topic model.</p>
<p>3.Applying clustering (e.g., Single-pass clustering) on Twitter data stream will create groups of similar tweets of varying sizes. Design an algorithm to detect events from such groups. Specifically, answer the following questions.</p>
<p><strong>（i）What role do entities play in detecting events? How would you reduce the cost of detecting entities?</strong></p>
<p>Entities can include named entities like people, organizations, locations, or other relevant terms specific to an event. By identifying and tracking entities within the tweet clusters, we can recognize emerging events and monitor their development. Entities can help:</p>
<ol>
<li>Identify the key components of an event: Entities can represent the primary subjects or objects related to an event, enabling us to understand the event’s main focus.</li>
<li>Differentiate between events: Entities can help distinguish between different events by providing context-specific information, which allows us to separate events with similar keywords but different contexts.</li>
<li>Track the progression of events: Monitoring the frequency and co-occurrence of entities over time can provide insights into how an event is evolving and help identify new developments or trends.</li>
</ol>
<p>Reducing the cost of detecting entities:</p>
<p>Detecting entities in real-time can be computationally expensive, especially for large-scale Twitter data streams. To reduce the cost of detecting entities, consider the following strategies:</p>
<ol>
<li>Entity extraction optimization: Use efficient named entity recognition (NER) tools or libraries that can handle streaming data, like spaCy or the Stanford NER. These libraries are optimized for performance and can handle large-scale text data efficiently.</li>
<li>Filter irrelevant data: Preprocess the Twitter data stream to remove irrelevant information, such as URLs, hashtags, user mentions, and stop words. This reduces the volume of data to process and allows the entity extraction to focus on relevant content.</li>
<li>Keyword-based entity detection: Instead of using full-fledged NER models, you can create a list of relevant keywords or entities specific to the domain of interest. This can help in detecting events of interest with lower computational cost.</li>
<li>Incremental entity extraction: Instead of processing the entire data stream at once, perform entity extraction incrementally as new tweets arrive. This can help distribute the computational load over time, making it more manageable.</li>
<li>Parallelization: Utilize parallel processing techniques to distribute the entity extraction task across multiple cores or machines, which can significantly speed up the process and reduce the overall computational cost.</li>
</ol>
<p>By incorporating these strategies, you can reduce the cost of detecting entities in Twitter data streams while still effectively identifying and tracking events.</p>
<p><strong>(ii)If you were to use tf-idf concepts for representation, how would you capture them?</strong></p>
<p>To capture TF-IDF concepts for representation in the context of detecting events from Twitter data, follow these steps:</p>
<ol>
<li><p>Data preprocessing: Preprocess the tweets by removing irrelevant information (e.g., URLs, hashtags, user mentions), tokenizing the text, removing stop words, converting all text to lowercase, and performing lemmatization or stemming.</p>
</li>
<li><p>Term Frequency (TF): Calculate the term frequency for each term in each tweet. The term frequency is the number of times a term appears in a tweet divided by the total number of terms in that tweet. This step normalizes the frequency of terms in each tweet, accounting for varying tweet lengths.</p>
</li>
<li><p>Inverse Document Frequency (IDF): Calculate the inverse document frequency for each term across the entire Twitter data stream. The IDF measures the importance of a term by considering its rarity in the entire dataset. To calculate IDF, first compute the document frequency (DF) – the number of tweets containing a particular term. Then, compute the IDF as the logarithm of the total number of tweets divided by the DF.</p>
</li>
<li><p>TF-IDF representation: Compute the TF-IDF score for each term in each tweet by multiplying the TF and IDF values. This score represents the importance of a term in a tweet while considering its rarity in the entire dataset.</p>
</li>
<li><p>Feature vectors: For each tweet, create a feature vector with the TF-IDF scores of its terms. This can be represented as a sparse vector where each dimension corresponds to a unique term from the entire vocabulary across all tweets, and its value is the TF-IDF score for that term in the specific tweet. If a term is not present in a tweet, its value in the vector will be zero.</p>
</li>
<li><p>计算TF（Term Frequency，词频）：对于给定的文档d和词语t，它的TF值可以通过如下公式计算：</p>
<p>TF(t, d) &#x3D; (词语t在文档d中出现的次数) &#x2F; (文档d中词语总数)</p>
<p>其中，分子表示词语t在文档d中出现的次数，分母表示文档d中所有词语的总数。TF值反映了词语在当前文档中的重要程度，即出现次数越多，TF值越大。</p>
</li>
<li><p>计算IDF（Inverse Document Frequency，逆文档频率）：对于语料库中的所有文档和词语t，它的IDF值可以通过如下公式计算：</p>
<p>IDF(t) &#x3D; log((语料库中文档的总数) &#x2F; (包含词语t的文档数+1))</p>
<p>其中，分子表示语料库中所有文档的总数，分母表示包含词语t的文档数（加1是为了避免分母为0）。IDF值反映了词语在整个语料库中的重要程度，即出现文档数越少，IDF值越大。</p>
</li>
<li><p>计算TF-IDF：将TF和IDF相乘，得到词语t在文档d中的TF-IDF值。</p>
<p>TF-IDF(t, d) &#x3D; TF(t, d) * IDF(t)</p>
<p>TF-IDF值反映了词语t在文档d中的重要程度，同时也考虑了词语在整个语料库中的出现情况。在计算TF-IDF时，还可以对TF值进行平滑处理，例如使用下面的公式：</p>
<p>TF(t, d) &#x3D; 0.5 + 0.5 * (词语t在文档d中出现的次数) &#x2F; (文档d中词语总数)</p>
<p>这种平滑处理可以避免长文档中某个词语的TF值过高的问题。</p>
</li>
</ol>
<p><strong>(iii) How do you remove noisy or spam groups?</strong></p>
<p>Removing noisy or spam groups from a dataset involves filtering out irrelevant or low-quality content. Here are some strategies to identify and remove such groups:</p>
<ol>
<li>Text-based filtering: Analyze the content of the groups and apply filters to eliminate groups containing certain keywords or patterns that are commonly associated with spam or noise. For example, you can create a list of common spam keywords, phrases, or patterns, and remove groups that contain a high frequency of these terms.</li>
<li>Frequency-based filtering: Analyze the posting frequency of the groups. Spam or noisy groups often exhibit unusual posting patterns, such as posting the same content repeatedly, or posting at extremely high frequencies. Set a threshold for acceptable posting frequency and filter out groups that exceed this limit.</li>
<li>User-based filtering: Analyze the users contributing to the groups. If a group consists mostly of users with suspicious behavior or characteristics (e.g., newly created accounts, accounts with very few followers or following a large number of users), it might be a spam or noisy group. You can create a scoring system to rate the credibility of users and filter out groups with a high proportion of low-credibility users.</li>
<li>Group size: Small groups or groups with very few members might be more likely to be noisy or spammy. You can set a minimum group size threshold and remove groups that fall below this limit.</li>
<li>Language-based filtering: Analyze the language used in the groups. Spam or noisy groups may contain a high proportion of irrelevant    r nonsensical text, or text in a language that is not of interest for your analysis. Use natural language processing techniques, such as language detection, to filter out groups with content in unwanted languages or with a high proportion of unintelligible text.</li>
<li>Machine learning techniques: Train a machine learning model to classify groups as spam, noisy, or relevant based on features like text content, posting frequency, user characteristics, group size, and language. This approach can be more adaptive and effective in identifying spam and noisy groups, especially if the model is regularly updated with new data.</li>
</ol>
<p>By applying these strategies, you can identify and remove noisy or spam groups from your dataset, allowing for more accurate and meaningful analysis of the remaining content.</p>
<p><strong>(iv) How would you identify categories of events?</strong></p>
<p>1.Visualization, use diagram to demonstrate the top 20 most frequent words in a group, this can help us understand the topic of a group and help us to categorize the groups. Or use the PCA to reduce the dimensionality of the data and project it to a lower space, find the overlaps.</p>
<p>2.Cluster labeling, Assign descriptive labels to the groups based on the representative information extracted in the previous step. You can manually analyze the most frequent terms, key phrases, or named entities in each group and assign a suitable category label. Alternatively, you can use an automated approach like extracting the most frequent terms or key phrases as labels.</p>
<p><strong>(v) Provide an algorithm for combining similar groups of tweets (e.g., tweets containing same entities).</strong></p>
<ol>
<li>Extract entities from each group:<ul>
<li>For each group, extract the named entities (e.g., people, organizations, locations) from the text of the tweets and articles.</li>
<li>You can use a Named Entity Recognition (NER) library like spaCy or Stanford NER to perform this task.</li>
</ul>
</li>
<li>Calculate entity similarity between groups:<ul>
<li>Create a function to compute the similarity between two groups based on the shared entities.</li>
<li>You can use the Jaccard similarity coefficient, which is the size of the intersection of entities divided by the size of the union of entities for each pair of groups.</li>
</ul>
</li>
<li>Combine similar groups based on a similarity threshold:<ul>
<li>Set a similarity threshold (e.g., 0.5) to decide whether two groups should be combined.</li>
<li>For each pair of groups:<ul>
<li>Compute the entity similarity using the function created in step 2.</li>
<li>If the similarity score is greater than or equal to the threshold:<ul>
<li>Combine the two groups into one.</li>
<li>Update the entity set of the combined group.</li>
<li>Remove the original groups from the list of groups.</li>
</ul>
</li>
</ul>
</li>
<li>Repeat this process until no more groups can be combined based on the similarity threshold.</li>
</ul>
</li>
</ol>
<p> <strong>here are some other features than entities you can use to combine similar groups:</strong></p>
<ol>
<li>Term Frequency (TF):<ul>
<li>Use the frequency of terms within each group as a feature. Calculate the similarity between groups based on the overlap of their most frequent terms.</li>
</ul>
</li>
<li>Key phrases:<ul>
<li>Extract key phrases from the text in each group using techniques like RAKE (Rapid Automatic Keyword Extraction) or TextRank. Compare the groups based on the overlap of their key phrases.</li>
</ul>
</li>
<li>Sentiment analysis:<ul>
<li>Calculate the average sentiment score of each group using a sentiment analysis library or pre-trained model. Combine groups with similar sentiment scores.</li>
</ul>
</li>
<li>Topic modeling:<ul>
<li>Apply topic modeling techniques like Latent Dirichlet Allocation (LDA) to the dataset. Compare groups based on the distribution of topics within each group.</li>
</ul>
</li>
<li>Word embeddings:<ul>
<li>Use pre-trained word embeddings like Word2Vec, GloVe, or BERT to represent the text within each group. Calculate the average embedding for each group and compare groups using cosine similarity or other distance metrics.</li>
</ul>
</li>
<li>N-grams:<ul>
<li>Extract N-grams (sequences of N consecutive words) from the text within each group. Compare groups based on the overlap of their most frequent N-grams.</li>
</ul>
</li>
<li>Text similarity:<ul>
<li>Calculate the average pairwise text similarity within each group using a text similarity measure like cosine similarity, Jaccard similarity, or edit distance. Combine groups with similar average text similarity scores.</li>
</ul>
</li>
<li>Hashtags and user mentions:<ul>
<li>For Twitter data, extract hashtags and user mentions from the tweets within each group. Compare groups based on the overlap of their most frequent hashtags and user mentions.</li>
</ul>
</li>
</ol>
<p>(vi) how do we find the brusting clusters?</p>
<p>To find bursting clusters, you can use a sliding window algorithm combined with a clustering method. The idea is to divide the data into time windows and apply clustering within each window to identify groups of similar items. By comparing the clusters across different time windows, you can detect bursts of activity. Here’s an outline of the algorithm:</p>
<ol>
<li>Divide the data into time windows:<ul>
<li>Choose an appropriate window size and step size based on the dataset and the expected duration of bursts.</li>
<li>Divide the data into non-overlapping or overlapping time windows accordingly.</li>
</ul>
</li>
<li>Apply clustering within each time window:<ul>
<li>For each time window, preprocess the data (e.g., tokenize, remove stop words, stemming&#x2F;lemmatization) and create feature vectors using methods like TF-IDF or word embeddings.</li>
<li>Apply a clustering algorithm (e.g., K-means, DBSCAN) to the feature vectors within the window to group similar items.</li>
</ul>
</li>
<li>Detect bursts by comparing clusters across adjacent time windows:<ul>
<li>Define a burst detection criterion, such as a significant increase in the number of items within a cluster or the emergence of a new cluster with a large number of items.</li>
<li>For each pair of adjacent time windows, compare the clusters and identify those that meet the burst detection criterion.</li>
</ul>
</li>
</ol>
<p>Here’s a pseudo-code for the algorithm:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">phpCopy code</span><br><span class="line">function preprocess_and_vectorize(data):</span><br><span class="line">    preprocessed_data = preprocess_text(data)</span><br><span class="line">    feature_vectors = create_feature_vectors(preprocessed_data)</span><br><span class="line">    return feature_vectors</span><br><span class="line"></span><br><span class="line">function cluster_data(feature_vectors):</span><br><span class="line">    clusters = apply_clustering_algorithm(feature_vectors)</span><br><span class="line">    return clusters</span><br><span class="line"></span><br><span class="line">function detect_bursts(window_clusters, burst_threshold):</span><br><span class="line">    bursts = []</span><br><span class="line">    for i in range(len(window_clusters) - 1):</span><br><span class="line">        for cluster in window_clusters[i]:</span><br><span class="line">            next_window_cluster = find_corresponding_cluster(cluster, window_clusters[i + 1])</span><br><span class="line">            if not next_window_cluster:</span><br><span class="line">                continue</span><br><span class="line">            growth = len(next_window_cluster) - len(cluster)</span><br><span class="line">            if growth &gt;= burst_threshold:</span><br><span class="line">                bursts.append((cluster, next_window_cluster))</span><br><span class="line">    return bursts</span><br><span class="line"></span><br><span class="line">data = load_data()</span><br><span class="line">window_size = ...</span><br><span class="line">step_size = ...</span><br><span class="line">burst_threshold = ...</span><br><span class="line"></span><br><span class="line">time_windows = create_time_windows(data, window_size, step_size)</span><br><span class="line">window_clusters = []</span><br><span class="line"></span><br><span class="line">for window in time_windows:</span><br><span class="line">    feature_vectors = preprocess_and_vectorize(window)</span><br><span class="line">    clusters = cluster_data(feature_vectors)</span><br><span class="line">    window_clusters.append(clusters)</span><br><span class="line"></span><br><span class="line">bursts = detect_bursts(window_clusters, burst_threshold)</span><br></pre></td></tr></table></figure>

<p>This algorithm divides the data into time windows, applies clustering within each window, and detects bursts based on changes in cluster sizes across adjacent windows. You can customize the window size, step size, clustering algorithm, and burst detection criterion based on your specific dataset and use case.</p>
<p>(b) Describe a methodology to predict stock trend prediction from social media data</p>
<p>StockNet (Deep Learning method)</p>
<p>StockNet is a hypothetical term that could refer to a network or system that aims to predict stock trends. While I’m not aware of a specific tool called “StockNet,” there are many approaches to predicting stock trends using machine learning and artificial intelligence techniques. One such approach is using deep learning models like recurrent neural networks (RNNs), long short-term memory (LSTM) networks, or convolutional neural networks (CNNs).</p>
<p>To use a deep learning model like “StockNet” to predict stock trends, follow these general steps:</p>
<ol>
<li>Data collection: Gather historical stock data, such as stock prices, trading volumes, and other relevant financial indicators. You may obtain this data from financial data providers, public financial statements, or web scraping.</li>
<li>Data preprocessing: Clean and preprocess the data to eliminate noise, handle missing values, and convert categorical data into numerical formats. This step may also involve feature engineering to create new features that may be relevant for prediction.</li>
<li>Feature scaling: Scale or normalize the features to ensure that they have similar ranges and are suitable for input into a deep learning model.</li>
<li>Train-test split: Split the dataset into training and testing sets. The training set will be used to train the model, while the testing set will be used to evaluate its performance.</li>
<li>Model selection: Choose an appropriate deep learning model based on your data and problem. Common choices include RNNs, LSTMs, and CNNs.</li>
<li>Model training: Train the selected model on the training data. This involves adjusting the model’s parameters to minimize the prediction error. You may need to experiment with different hyperparameters, such as learning rate, batch size, and the number of hidden layers.</li>
<li>Model evaluation: Evaluate the model’s performance on the testing data. Common evaluation metrics include mean squared error (MSE), mean absolute error (MAE), and R-squared.</li>
<li>Fine-tuning: If the model’s performance is unsatisfactory, fine-tune it by adjusting the hyperparameters, modifying the model architecture, or changing the features used.</li>
<li>Prediction: Once the model has been fine-tuned and performs well on the testing data, use it to predict future stock trends based on the input features.</li>
</ol>
<p>Keep in mind that predicting stock trends is inherently difficult due to the complex and dynamic nature of financial markets. No model can guarantee accurate predictions, and it is essential to manage risks and avoid relying solely on model predictions for making investment decisions.</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        Share
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/04/28/webscience/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2023/04/25/DSA/" class="article-nav-link">
        <strong class="article-nav-caption">Next Post</strong>
        <div class="article-nav-title">DSA</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2023
        <i class="ri-heart-fill heart_icon"></i> Mingwei Li
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Mingwei’s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">Travel</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>