<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="joshua" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>kubernetes |  Mingwei’s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/UoG.svg" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Mingwei’s Blog" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-kubernetes"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  kubernetes
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/06/26/kubernetes/" class="article-date">
  <time datetime="2023-06-26T10:03:56.000Z" itemprop="datePublished">2023-06-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">3.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">16 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Kubernetes is a portable, extensible, open source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available.</p>
<ul>
<li>When you deploy Kubernetes, you get a cluster.</li>
<li>A Kubernetes cluster consists of a set of worker machines, called <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/">nodes</a>, that run containerized applications.</li>
<li>Every cluster has at least one worker node.</li>
</ul>
<h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>This document outlines the various components you need to have for a complete and working Kubernetes cluster.</p>
<h3 id="Control-Plane-components"><a href="#Control-Plane-components" class="headerlink" title="Control Plane components"></a>Control Plane components</h3><h4 id="kube-api-server"><a href="#kube-api-server" class="headerlink" title="kube-api server"></a><strong>kube-api server</strong></h4><p>The API server is the front end for the Kubernetes control plane.</p>
<p>The main implementation of a Kubernetes API server is <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kube-apiserver/">kube-apiserver</a>. kube-apiserver is designed to scale horizontally—that is, it scales by deploying more instances. You can run several instances of kube-apiserver and balance traffic between those instances.</p>
<p><strong>Horizontal scaling vs Vertical scaling:</strong></p>
<p><strong>水平扩展</strong></p>
<p>是通过增加或减少工作负载的实例数量来调整资源的过程。在 Kubernetes 中，这通常是通过增加或减少 Pod 的副本数量来实现的。例如，如果一个应用程序的负载增加，可以增加 Pod 的数量来分散负载。这通常是通过使用 Kubernetes 的 Horizontal Pod Autoscaler (HPA) 来自动完成的，HPA 根据 CPU 利用率或其他选择的度量标准来自动调整 Pod 的数量。<br>水平扩展通常适用于无状态应用程序，因为增加的实例可以独立处理请求，不需要访问共享资源。</p>
<p><strong>垂直扩展</strong></p>
<p>是通过增加或减少单个实例的资源（如 CPU 或内存）来调整资源的过程。在 Kubernetes 中，这通常是通过增加或减少 Pod 的资源限制和请求来实现的。</p>
<p>例如，如果一个应用程序的性能受到 CPU 或内存的限制，可以增加 Pod 的 CPU 或内存资源来提高性能。</p>
<p>垂直扩展通常适用于有状态应用程序，因为这些应用程序通常需要访问共享资源，而且可能不容易在多个实例之间分散负载。</p>
<h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a><strong>etcd</strong></h4><p>Consistent and highly-available key value store used as Kubernetes’ backing store for all cluster data. If your Kubernetes cluster uses etcd as its backing store, make sure you have a back up plan for the data.</p>
<h4 id="Kube-scheduler"><a href="#Kube-scheduler" class="headerlink" title="Kube-scheduler"></a><strong>Kube-scheduler</strong></h4><p>Control plane component that watches for newly created Pods with no assigned node, and selects a node for them to run on. Factors taken into account for scheduling decisions include: individual and collective resource requirements, hardware&#x2F;software&#x2F;policy constraints, affinity and anti-affinity specifications, data locality, inter-workload interference, and deadlines.</p>
<h4 id="Kube-controller-manager"><a href="#Kube-controller-manager" class="headerlink" title="Kube-controller-manager"></a>Kube-controller-manager</h4><p>Control plane component that runs <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/controller/">controller</a> processes. Logically, each <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/controller/">controller</a> is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process. </p>
<p>Some types of these controllers are:</p>
<ul>
<li>Node controller: Responsible for noticing and responding when nodes go down.</li>
<li>Job controller: Watches for Job objects that represent one-off tasks, then creates Pods to run those tasks to completion.</li>
<li>EndpointSlice controller: Populates EndpointSlice objects (to provide a link between Services and Pods).</li>
<li>ServiceAccount controller: Create default ServiceAccounts for new namespaces.</li>
</ul>
<h4 id="Cloud-controller-manager"><a href="#Cloud-controller-manager" class="headerlink" title="Cloud-controller-manager"></a>Cloud-controller-manager</h4><p>A Kubernetes <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/glossary/?all=true#term-control-plane">control plane</a> component that embeds cloud-specific control logic. The cloud controller manager lets you link your cluster into your cloud provider’s API, and separates out the components that interact with that cloud platform from components that only interact with your cluster.</p>
<h3 id="Node-Components"><a href="#Node-Components" class="headerlink" title="Node Components"></a>Node Components</h3><h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><p>An agent that runs on each <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/">node</a> in the cluster. It makes sure that <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/containers/">containers</a> are running in a <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/">Pod</a>.</p>
<h4 id="Kube-proxy"><a href="#Kube-proxy" class="headerlink" title="Kube-proxy"></a>Kube-proxy</h4><p>kube-proxy is a network proxy that runs on each <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/">node</a> in your cluster, implementing part of the Kubernetes <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> concept.	</p>
<h4 id="Container-runtime"><a href="#Container-runtime" class="headerlink" title="Container-runtime"></a>Container-runtime</h4><p>The container runtime is the software that is responsible for running containers.</p>
<h3 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a>Addons</h3><p>Addons use Kubernetes resources (<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset">DaemonSet</a>, <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a>, etc) to implement cluster features. Because these are providing cluster-level features, namespaced resources for addons belong within the <code>kube-system</code> namespace.</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>While the other addons are not strictly required, all Kubernetes clusters should have <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/">cluster DNS</a>, as many examples rely on it.</p>
<h4 id="Web-UI-Dashboard"><a href="#Web-UI-Dashboard" class="headerlink" title="Web-UI(Dashboard)"></a>Web-UI(Dashboard)</h4><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">Dashboard</a> is a general purpose, web-based UI for Kubernetes clusters. It allows users to manage and troubleshoot applications running in the cluster, as well as the cluster itself.</p>
<h4 id="Container-Resource-Monitoring"><a href="#Container-Resource-Monitoring" class="headerlink" title="Container Resource Monitoring"></a>Container Resource Monitoring</h4><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-usage-monitoring/">Container Resource Monitoring</a> records generic time-series metrics about containers in a central database, and provides a UI for browsing that data.</p>
<h4 id="Cluster-level-Logging"><a href="#Cluster-level-Logging" class="headerlink" title="Cluster-level Logging"></a>Cluster-level Logging</h4><p>A <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/cluster-administration/logging/">cluster-level logging</a> mechanism is responsible for saving container logs to a central log store with search&#x2F;browsing interface.</p>
<h4 id="Network-Plugins"><a href="#Network-Plugins" class="headerlink" title="Network Plugins"></a>Network Plugins</h4><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins">Network plugins</a> are software components that implement the container network interface (CNI) specification. They are responsible for allocating IP addresses to pods and enabling them to communicate with each other within the cluster.</p>
<h1 id="Elementary"><a href="#Elementary" class="headerlink" title="Elementary"></a>Elementary</h1><h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h2><p>A cluster is made by nodes(master node and worker nodes), Master is used to managed the cluster. <strong>Worker节点是虚拟机或物理计算机，充当k8s集群中的工作计算机。</strong> 每个Worker节点都有一个Kubelet，它管理该Worker节点并负责与Master节点通信。该Worker节点还应具有用于处理容器操作的工具，例如Docker。</p>
<p>A node is made by pods</p>
<p>Pod is created by deployment, you can specify how many replicas you want. You can use deployment to manage these pods replicas.</p>
<p>A pod is made by containers.</p>
<h2 id="1-部署一个应用程序"><a href="#1-部署一个应用程序" class="headerlink" title="1.部署一个应用程序"></a>1.部署一个应用程序</h2><p>首先得创建一个yaml文件，里面包含了</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>	<span class="comment">#与k8s集群版本有关，使用 kubectl api-versions 即可查看当前集群支持的版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>	<span class="comment">#该配置的类型，我们使用的是 Deployment</span></span><br><span class="line"><span class="attr">metadata:</span>	        <span class="comment">#译名为元数据，即 Deployment 的一些基本属性和信息</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span>	<span class="comment">#Deployment 的名称</span></span><br><span class="line">  <span class="attr">labels:</span>	    <span class="comment">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>	<span class="comment">#为该Deployment设置key为app，value为nginx的标签</span></span><br><span class="line"><span class="attr">spec:</span>	        <span class="comment">#这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>	<span class="comment">#使用该Deployment创建一个应用程序实例</span></span><br><span class="line">  <span class="attr">selector:</span>	    <span class="comment">#标签选择器，与上面的标签共同作用，目前不需要理解</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment">#选择包含标签app:nginx的资源</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span>	    <span class="comment">#这是选择或创建的Pod的模板</span></span><br><span class="line">    <span class="attr">metadata:</span>	<span class="comment">#Pod的元数据</span></span><br><span class="line">      <span class="attr">labels:</span>	<span class="comment">#Pod的标签，上面的selector即选择包含标签app:nginx的Pod</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span>	    <span class="comment">#期望Pod实现的功能（即在pod中部署）</span></span><br><span class="line">      <span class="attr">containers:</span>	<span class="comment">#生成container，与docker中的container是同一种</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>	<span class="comment">#container的名称</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span>	<span class="comment">#使用镜像nginx:1.7.9创建container，该container默认80端口可访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure>

<p>这样应该就能够看见了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Deployment</span></span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-查看pods-x2F-nodes"><a href="#2-查看pods-x2F-nodes" class="headerlink" title="2.查看pods&#x2F;nodes"></a>2.查看pods&#x2F;nodes</h2><p>在部署完一个应用程序后，k8s创建了一个deployment，由它创建了一个pod来放置应用程序实例也就是container</p>
<p>在一个pod中，里面的容器containers会共享</p>
<ul>
<li>共享存储，称为卷(Volumes)，即图上紫色圆柱</li>
<li>网络，每个 Pod（容器组）在集群中有个唯一的 IP，pod（容器组）中的 container（容器）共享该IP地址</li>
<li>container（容器）的基本信息，例如容器的镜像版本，对外暴露的端口等</li>
</ul>
<p>Pod（容器组）是 k8s 集群上的最基本的单元。当我们在 k8s 上创建 Deployment 时，会在集群上创建包含容器的 Pod (而不是直接创建容器)。每个Pod都与运行它的 worker 节点（Node）绑定，并保持在那里直到终止或被删除。如果节点（Node）发生故障，则会在群集中的其他可用节点（Node）上运行相同的 Pod(从同样的镜像创建 Container，使用同样的配置，IP 地址不同，Pod 名字不同)。</p>
<p>Node </p>
<p>![截屏2023-07-15 14.42.27](..&#x2F;images&#x2F;截屏2023-07-15 14.42.27.png)</p>
<p>Pod总是在 <strong>Node</strong> 上运行。Node是 kubernetes 集群中的计算机，可以是虚拟机或物理机。每个 Node都由 master 管理。一个 Node可以有多个Pod，kubernetes master 会根据每个 Node上可用资源的情况，自动调度 Pod到最佳的 Node上。</p>
<p>每个 Kubernetes Node至少运行：</p>
<ul>
<li>Kubelet，负责 master 节点和 worker 节点之间通信的进程；管理 Pod和 Pod内运行的 Containers.</li>
<li>容器运行环境（如Docker）负责下载镜像、创建和运行容器等.</li>
</ul>
<p><strong>kubectl 还有如下四个常用命令，在我们排查问题时可以提供帮助：</strong></p>
<p><strong>kubectl get – 资源类型,</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取类型为Deployment的资源列表</span></span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取类型为Pod的资源列表</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取类型为Node的资源列表</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>名称空间</p>
<p>在命令后增加 <code>-A</code> 或 <code>--all-namespaces</code> 可查看所有 <a target="_blank" rel="noopener" href="https://kuboard.cn/learning/k8s-intermediate/obj/namespaces.html">名称空间中</a> 的对象，使用参数 <code>-n</code> 可查看指定名称空间的对象，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有名称空间的 Deployment</span></span><br><span class="line">kubectl get deployments -A</span><br><span class="line">kubectl get deployments --all-namespaces</span><br><span class="line"><span class="comment"># 查看 kube-system 名称空间的 Deployment</span></span><br><span class="line">kubectl get deployments -n kube-system</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>kubectl describe</strong> - 显示有关资源的详细信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl describe 资源类型 资源名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看名称为nginx-XXXXXX的Pod的信息</span></span><br><span class="line">kubectl describe pod nginx-XXXXXX	</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看名称为nginx的Deployment的信息</span></span><br><span class="line">kubectl describe deployment nginx	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Kubectl logs</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl logs Pod名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看名称为nginx-pod-XXXXXXX的Pod内的容器打印的日志</span></span><br><span class="line"><span class="comment">#本案例中的 nginx-pod 没有输出日志，所以您看到的结果是空的</span></span><br><span class="line">kubectl logs -f nginx-pod-XXXXXXX</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Kubectl exec</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl exec Pod名称 操作命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在名称为nginx-pod-xxxxxx的Pod中运行bash</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx-pod-xxxxxx /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TIP</p>
<p>Worker节点是k8s中的工作计算机，可能是VM或物理计算机，具体取决于群集。多个Pod可以在一个节点上运行。</p>
<h2 id="3-公布应用程序"><a href="#3-公布应用程序" class="headerlink" title="3.公布应用程序"></a>3.公布应用程序</h2><p>Kubernetes service</p>
<p>Pod有自己的生命周期。当worker node故障的时候，节点上运行的pod也会消失，然后deployment可以通过创建新的 Pod（容器组）来动态地将群集调整回原来的状态，以使应用程序保持运行。</p>
<p>举个例子，假设有一个图像处理后端程序，具有 3 个运行时副本。这 3 个副本是可以替换的（无状态应用），即使 Pod消失并被重新创建，或者副本数由 3 增加到 5，前端系统也无需关注后端副本的变化。由于 Kubernetes 集群中每个 Pod都有一个唯一的 IP 地址（即使是同一个 Node 上的不同 Pod），我们需要一种机制，为前端系统屏蔽后端系统的 Pod在销毁、创建过程中所带来的 IP 地址的变化。</p>
<p>kubernetes 的 service就提供这样的功能，它提供了这样的一个抽象层，它选择具备某些特征的 Pod并为它们定义一个访问方式。Service使Pod之间的相互依赖解耦（原本从一个 Pod 中访问另外一个 Pod，需要知道对方的 IP 地址）。一个 Service选定哪些<strong>Pod</strong>通常由<strong>LabelSelector</strong>来决定。</p>
<p>在创建Service的时候，通过设置配置文件中的 spec.type 字段的值，可以以不同方式向外部暴露应用程序：</p>
<ul>
<li><p><strong>ClusterIP</strong>（默认）</p>
<p>在群集中的内部IP上公布服务，这种方式的 Service（服务）只在集群内部可以访问到</p>
</li>
<li><p><strong>NodePort</strong></p>
<p>使用 NAT 在集群中每个的同一端口上公布服务。这种方式下，可以通过访问集群中任意节点+端口号的方式访问服务 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>。此时 ClusterIP 的访问方式仍然可用。</p>
</li>
<li><p><strong>LoadBalancer</strong></p>
<p>在云环境中（需要云供应商可以支持）创建一个集群外部的负载均衡器，并为使用该负载均衡器的 IP 地址作为服务的访问地址。此时 ClusterIP 和 NodePort 的访问方式仍然可用。</p>
</li>
</ul>
<p><strong>TIPs</strong></p>
<p>Service是一个抽象层，它通过 LabelSelector 选择了一组 Pod（容器组），把这些 Pod 的指定端口公布到到集群外部，并支持负载均衡和服务发现。</p>
<ul>
<li>公布 Pod 的端口以使其可访问</li>
<li>在多个 Pod 间实现负载均衡</li>
<li>使用 Label 和 LabelSelector</li>
</ul>
<p>下图中有两个服务<strong>Service A(黄色虚线)<strong>和</strong>Service B(蓝色虚线)</strong> Service A 将请求转发到 IP 为 10.10.10.1 的Pod上， Service B 将请求转发到 IP 为 10.10.10.2、10.10.10.3、10.10.10.4 的Pod上。</p>
<p>![截屏2023-07-15 16.17.04](..&#x2F;images&#x2F;截屏2023-07-15 16.17.04.png)</p>
<p>Service 将外部请求路由到一组 Pod 中，它提供了一个抽象层，使得 Kubernetes 可以在不影响服务调用者的情况下，动态地调度pods(在容器组失效后重新创建容器组，增加或者减少同一个 Deployment 对应容器组的数量等).</p>
<p>Service使用 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels">Labels、LabelSelector(标签和选择器) (opens new window)</a>匹配一组 Pod。Labels（标签）是附加到 Kubernetes 对象的键值对，其用途有多种：</p>
<ul>
<li>将 Kubernetes 对象（Node、Deployment、Pod、Service等）指派用于开发环境、测试环境或生产环境</li>
<li>嵌入版本标签，使用标签区别不同应用软件版本</li>
<li>使用标签对 Kubernetes 对象进行分类</li>
</ul>
<p>下图体现了 Labels（标签）和 LabelSelector（标签选择器）之间的关联关系</p>
<ul>
<li><p>Deployment B 含有 LabelSelector 为 app&#x3D;B 通过此方式声明含有 app&#x3D;B 标签的 Pod 与之关联</p>
</li>
<li><p>通过 Deployment B 创建的 Pod 包含标签为 app&#x3D;B</p>
</li>
<li><p>Service B 通过标签选择器 app&#x3D;B 选择可以路由的 Pod</p>
<p>![截屏2023-07-15 16.24.25](..&#x2F;images&#x2F;截屏2023-07-15 16.24.25.png)</p>
</li>
</ul>
<p>Labels可以在创建 Kubernetes 对象时附加上去，也可以在创建之后再附加上去。任何时候都可以修改一个 Kubernetes 对象的 Labels.</p>
<p><strong>实战:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">metadata:	<span class="comment">#译名为元数据，即Deployment的一些基本属性和信息</span></span><br><span class="line">  name: nginx-deployment	<span class="comment">#Deployment的名称</span></span><br><span class="line">  labels:	<span class="comment">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组</span></span><br><span class="line">    app: nginx	<span class="comment">#为该Deployment设置key为app，value为nginx的标签</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx-service.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service	<span class="comment">#Service 的名称</span></span><br><span class="line">  labels:     	<span class="comment">#Service 自己的标签</span></span><br><span class="line">    app: nginx	<span class="comment">#为该 Service 设置 key 为 app，value 为 nginx 的标签</span></span><br><span class="line">spec:	    <span class="comment">#这是关于该 Service 的定义，描述了 Service 如何选择 Pod，如何被访问</span></span><br><span class="line">  selector:	    <span class="comment">#标签选择器</span></span><br><span class="line">    app: nginx	<span class="comment">#选择包含标签 app:nginx 的 Pod</span></span><br><span class="line">  ports:</span><br><span class="line">  - name: nginx-port	<span class="comment">#端口的名字</span></span><br><span class="line">    protocol: TCP	    <span class="comment">#协议类型 TCP/UDP</span></span><br><span class="line">    port: 80	        <span class="comment">#集群内的其他容器组可通过 80 端口访问 Service</span></span><br><span class="line">    nodePort: 32600   <span class="comment">#通过任意节点的 32600 端口访问 Service</span></span><br><span class="line">    targetPort: 80	<span class="comment">#将请求转发到匹配 Pod 的 80 端口</span></span><br><span class="line">  <span class="built_in">type</span>: NodePort	<span class="comment">#Serive的类型，ClusterIP/NodePort/LoaderBalancer</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">kubectl apply -f nginx-service.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查执行结果</span></span><br><span class="line">kubectl get services -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可查看到名称为 nginx-service 的服务。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问服务</span></span><br><span class="line">curl &lt;任意节点的 IP&gt;:32600</span><br></pre></td></tr></table></figure>



<h2 id="4-Scaling"><a href="#4-Scaling" class="headerlink" title="4. Scaling"></a>4. Scaling</h2><p>Sacling应用程序</p>
<p>在之前的文章中，我们创建了一个 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment </a>，然后通过 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/">service</a>提供访问 Pod 的方式。我们发布的 Deployment 只创建了一个 Pod 来运行我们的应用程序。当流量增加时，我们需要对应用程序进行伸缩操作以满足系统性能需求。</p>
<p><strong>Scaling</strong> 的实现可以通过更改 nginx-deployment.yaml 文件中部署的 replicas（副本数）来完成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  replicas: 2    <span class="comment">#使用该Deployment创建两个应用程序实例</span></span><br></pre></td></tr></table></figure>

<p>![截屏2023-07-16 00.01.42](..&#x2F;images&#x2F;截屏2023-07-16 00.01.42.png)</p>
<p>修改了 Deployment 的 replicas 为 4 后，Kubernetes 又为该 Deployment 创建了 3 新的 Pod，这 4 个 Pod 有相同的标签。因此Service A通过标签选择器与新的 Pod建立了对应关系，将访问流量通过负载均衡在 4 个 Pod 之间进行转发。</p>
<p>![截屏2023-07-16 00.02.26](..&#x2F;images&#x2F;截屏2023-07-16 00.02.26.png)</p>
<h2 id="5-Rolling-update"><a href="#5-Rolling-update" class="headerlink" title="5.Rolling update"></a>5.Rolling update</h2><p>用户期望应用程序始终可用，为此开发者&#x2F;运维者在更新应用程序时要分多次完成。在 Kubernetes 中，这是通过 Rolling Update 滚动更新完成的。<strong>Rolling Update滚动更新</strong> 通过使用新版本的 Pod 逐步替代旧版本的 Pod 来实现 Deployment 的更新，从而实现零停机。新的 Pod 将在具有可用资源的 Node（节点）上进行调度。</p>
<p>Kubernetes 更新多副本的 Deployment 的版本时，会逐步的创建新版本的 Pod，逐步的停止旧版本的 Pod，以便使应用一直处于可用状态。这个过程中，Service 能够监视 Pod 的状态，将流量始终转发到可用的 Pod 上。</p>
<h1 id="Intermediate"><a href="#Intermediate" class="headerlink" title="Intermediate"></a>Intermediate</h1><h1 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h1> 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        Share
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/06/26/kubernetes/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tech/" rel="tag">tech</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/09/26/network/" class="article-nav-link">
        <strong class="article-nav-caption">Previous Post</strong>
        <div class="article-nav-title">
          
            Network
          
        </div>
      </a>
    
    
      <a href="/2023/06/19/project-notes/" class="article-nav-link">
        <strong class="article-nav-caption">Next Post</strong>
        <div class="article-nav-title">project_notes</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2024
        <i class="ri-heart-fill heart_icon"></i> Mingwei Li
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/UofG.png" alt="Mingwei’s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/CV">Personal</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/travel">Travel</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>Buy me a bottle of beer please~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>